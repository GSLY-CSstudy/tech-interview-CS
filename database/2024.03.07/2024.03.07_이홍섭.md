## Key

#### 슈퍼키와 기본키의 차이점을 아시나요? 
>- 기본키 (Primary Key): 기본키는 각 행을 고유하게 식별하는 역할을 합니다. 즉, 테이블 내의 각 행을 구별하는데 사용되며, 중복된 값을 가질 수 없습니다. 기본키로 지정된 열은 NULL 값을 가질 수 없으며, 해당 열은 반드시 값이 있어야 합니다. 데이터베이스에서 관리되는 주요 식별자로 사용됩니다.
>- 슈퍼키 (Super Key): 슈퍼키는 테이블 내의 행을 고유하게 식별할 수 있는 한 개 이상의 열의 집합입니다. 즉, 슈퍼키는 유일성을 보장하지 않을 수 있으며, 중복된 값을 포함할 수도 있습니다. 슈퍼키는 기본키의 후보가 될 수 있으며, 기본키의 선정에 영향을 미칩니다.
>- 즉 슈퍼키는 조합이 가능하다. 하나이상의 속성들의 집합으로 이루어진 것

#### 기본키는 수정이 가능한가요?
>- 연관관계가 존재하지 않는 기본키는 수정은 가능하나, 유니크한 값이어야한다.
>- cascade 설정이 되어있지 않는 연관관계에 있는 기본키 또는 외래키는 수정이 불가능하다.
>- cacade 설정이 되어 있는 연관관계의 경우 외래키는 수정되지 않는다.

#### MySQL의 경우 기본키를 설정하지 않아도 테이블이 만들어지는 이유?
>- MySQL에서 자체적으로 테이블의 속성 중 값에  Null 값이 없고, 레코드마다 고유한 첫 속성을 골라 클러스터형 인덱스로 지정한다.
>- 만약 테이블에 기본키 또는 적절한 고유 값의 인덱스가 존재하지 않는다면, InnoDB가 자체적으로 클러스터형 인덱스를 생성한다.
>    - **클러스터형 인덱스** : 해당 키 값을 기반으로 테이블의 데이터 행을 정렬하고 저장한다. 데이터는 오직 하나의 순서로 정렬될 수 있기에 클러스터형 인덱스는 테이블당 최대 한개만 존재 가능
>    - 비클러스터형 인덱스 : 비클러스터형 인덱스 키값을 가지고 각 키 값 레코드는 그 키값을 가지는 레코드를 향한 포인터를 가진다.

#### 외래키의 값은 NULL이 들어올 수 있나요? 간단한 예시를 들어서 설명해주시겠어요?
>- 가능하다.
>- ex) 학생은 하나의 동아리를 갖는다. 하지만 신입생은 아직 동아리가 정해지지 않았을 수도 있다.

#### 어떤 칼럼의 정의에 Unique 키워드가 붙는다고 가정하면, 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
>- 처음 값을 추가할 경우에는 전체 칼럼을 검색해야 해서 느리다. (유니크 한지 아닌지 확인)
>- 하지만 이후 조회시에는하나의 index를 찾았을 때 유니크 값이 보장되니 빠르게 검색 가능

## RDB vs NoSQL
#### NoSQL이란 무엇이고 어떠한 경우에 사용하는 것이 좋나요?
>- NoSQL 테이터베이스란 전통적인 관계형 모델에서 벗어나서 다양한 데이터 모델을 사용하여 데이터의 관리와 접근을 지원하는 데이터베이스를 의미합니다. NoSQL은 데이터의 스펙이 자주 변경되는 경우나, Read 작업이 자주 일어나는 경우, 수 많은 양의 데이터를 다루기 위해 수평 확장이 자주 필요한 경우에 사용하면 좋습니다.

#### NoSQL 장단점
>- NoSQL의 장점으로는 스키마가 없거나 느슨하게 제공되기 때문에 요구사항 변경에 유연하게 대처할 수 있습니다. 또한 관계형 데이터베이스에 비해 수평 확장이 쉽기 때문에 대용량 데이터 처리시 성능상의 이점을 얻어갈 수 있습니다.
>- NoSQL의 단점으로는 데이터베이스마다 사용하는 데이터의 모델이 다르기 때문에 이를 도입하기 위해서는 해당 데이터베이스를 깊게 공부해야해서 익숙한 관계형 데이터베이스보단 학습 비용이 많이 든다는 단점이 존재하구요, SQL처럼 **엄격한 제약조건이 존재하지 않기 때문에 데이터를 수정하거나 삭제하는 경우 모든 컬렉션에 걸쳐서 이를 반영해야 하는 단점이 존재합니다.**

#### 사용해보신 NoSQL이 있으시나요? 있다면 무엇이고 왜 사용했는지 알려주세요.

#### 데이터 모델에 따라 NoSQL을 분류한다면 어떻게 분류할 수 있을까요?
>- 대표적으로 하나의 키에 하나의 데이터가 저장되는 Key-Value Data Model을 채택하고 있는 데이터베이스와 Key-Value 모델을 개념적으로 확장해서 하나의 키에 하나의 구조화된 문서를 저장하는 Document Data Model을 채택한 데이터베이스 등으로 나눌 수 있을것 같습니다. Key-Value Data Model을 채택하고 있는 데이터베이스는 대표적으로 Redis를 들 수 있구요, Document Data Model을 채택하고 있는 데이터베이스는 대표적으로 MongoDB가 존재합니다.

## 레플리케이션/클러스터링

#### 레플리케이션에 대해서 설명해주세요.
>- 여러개의 데이터베이스를 권한에 따라 **수직적**인 구조로 구축하는 방식 `(마스터-슬레이브)`
>- 마스터 노드는 쓰기 작업, 슬레이브 노드는 읽기 작업만 수행한다.

#### 레플리케이션 동작 방식에 대해서 아시나요?
>1. 마스터 노드에 쓰기 트랜잭션이 수행된다
>2. 마스터 노드는 데이터를 저장하고 트랜잭션에 대한 로그를 Binary Log에 기록한다
>3. 슬레이브 노드의 IO 스레드는 마스터 노드의 Binary Log을 Replay Log에 복사한다
>4. 슬레이브 노드의 SQL 스레드는 Replay Log를 한줄씩 읽어 데이터를 저장한다

#### 레플리케이션에서 Binary Log와 Relay Log는 어떻게 사용되죠?
>`Binary Log`: DB 변경 내용을 기록하는데 이용하는 로그.<br>
>`Relay Log:` Slave DB에만 위치하고, 마스터 DB의 Binary Log을 복사해 저장하는데 이용하는 로그.

#### 파티셔닝과 샤딩의 차이는 뭔가요?
>- 파티셔닝은 일반적으로 **DB 테이블을 작은 부분으로 여러 개 나누는 것**을 의미합니다.
>- 파티셔닝은 열에 대해서 수직으로 혹은 행에 대해 수평으로 나누는 두 가지 방법이 존재합니다.
>- 샤딩은 수평 파티셔닝의 특수한 형태로 shard key로 알려진 특수한 키를 기준으로 데이터를 나눕니다. 그리고 **나눈 데이터들을 여러 노드에 나누어 저장**하는 방식을 의미합니다.
>- 샤딩을 하게되면 수평 파티셔닝이기 때문에 데이터 베이스 스키마가 그대로 유지됩니다.

## 정규화
#### 정규화에 대해서 알고 계신가요?
>- 이상현상이 있는 릴레이션을 분해해 이상 현상을 없앤 과정으로, 이상현상이 존재하는 릴레이션을 분해해서 여러개의 릴레이션을 생성한다. 정규형이 높아질수록 이상현상은 줄어들게 된다.

#### 이상 현상이 무엇을 말하나요 ?
>- 릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)

#### 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요
>- 역정규화란 성능향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 데이터 통합/분할/추가, 중복 속성 추가 등으로 구현할 수 있다.
>역정규화를 수행하면 테이블이 단순해져서 관리 효율성이 증가하지만, 데이터 무결성/일관성은 보장되지 않을 수 있다.<br>
>
> **역정규화가 필요할때**
>- 수행 속도가 현저히 느릴때
>- 테이블의 조인 연산이 지나치게 많이 필요해서 데이터를 조회하는 것이 어려울 때
>- 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특점 범위를 자주 처리해야 하는 경우
