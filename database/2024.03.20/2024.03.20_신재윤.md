
# GSLY 면접스터디

**3주차 질문 목록**

- **GSLY 면접스터디**
  - [3번 질의](#3번-질의)
  - [4번 질의](#4번-질의)
  - [11번 질의](#11번-질의)
  - [참고 자료](#참고-자료)

<hr>

## 3번 질의

<details><summary>3-1. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요. (출처 : vsfe)</summary>

<br>

- <ins>트랜잭션 : 단일한 논리적인 작업 단위 (a single logical unit of work)</ins>
  - 대표적으로 데이터베이스에서 트랜잭션 단위로 작업 처리를 많이 함
  - DB에 특정되는 것이 아님. 메시징 큐 트랜잭션도 있음
  - 특히, 분산 환경(MSA)에서 논리적인 작업 단위인 트랜잭션이 매우 중요!

<br>

- <ins>ACID : 데이터베이스 트랜잭션이 안전하게 수행 된다는 것을 보장하기 위한 것으로, Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성)이 있다.</ins>

<br>

- <ins>Atomicity (원자성)</ins>
  - 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장하는 것
  - All or Nothing

<br>

- <ins>Consistency (일관성)</ins>
  - 트랜잭션이 정의된 모든 제약 조건과 규칙을 준수하면서 데이터베이스를 하나의 일관된 상태에서 다른 일관된 상태로 이동하도록 보장하는 것
  - 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라, 자금 이체의 예시에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건도 포함

<br>

- <ins>Isolation (고립성, 격리성)</ins>
  - 여러 트랜잭션이 동시에 수행되는 경우, 각 트랜잭션은 다른 트랜잭션에 영향받지 않고 독립적으로 실행되도록 보장하는 것
  - Concurrency Control(동시성 제어)의 주된 목표
  - DBMS는 여러 종류의 격리 수준을 제공함

<br>

- <ins>Durability (지속성)</ins>
  - 트랜잭션이 커밋되고 나면, 하드웨어나 소프트웨어 장애에도 해당 트랜잭션에 의한 모든 변경은 보존하도록 보장하는 것


</details>

<br>

<details><summary>3-2. 데이터베이스 트랜잭션을 관리하기 위해, DBMS는 어떤 식으로 관리하나요? (창작 문제)</summary>

<br>

- DBMS는 버퍼 관리자(=페이지 버퍼)의 버퍼 관리 정책으로 트랜잭션을 관리한다.
  - 버퍼 관리 정책에 따라 UNDO 복구나 REDO 복구가 필요하거나 필요하지 않게 된다.
  - UNDO 복구나 REDO 복구를 위해 다양한 기법이 있지만, 보편적으로 로그 기법을 사용한다.

<br>

- <details><summary>상세한 내용 살펴보기</summary><br><ul><li>DBMS의 개략적인 구조<ul><br><p align="center"><img src="../image/2024.03.20-신재윤-image01.png" height="50%", width="75%"></p><li>DBMS는 보통 비휘발성 저장 장치인 디스크(ex.SSD)에 데이터를 저장하며 전체 데이터베이스의 일부분을 메인 메모리(RAM)에 유지</li><li>DBMS는 데이터를 고정 길이의 페이지(page)로 저장하며, 디스크에서 읽거나 쓸 때에 페이지 단위로 입출력</li><li>메인 메모리(RAM)에 유지하는 페이지들을 관리하는 모듈을 보통 페이지 버퍼(page buffer) 관리자 또는 버퍼 관리자라고 함</li><li>DBMS는 각 제품마다 구조가 다르기는 하지만, 크게 질의 처리기(Query Processor)와 저장 시스템(Storage System)으로 나눠볼 수 있음<ul><li>MySQL의 경우에는 InnoDB, MyISAM 등과 같이 여러 하부 저장 시스템을 선택할 수 있음. 모듈만 바꿔끼우면 되니까 편함 </li></ul></li></ul></li></ul><br><ul><li>UNDO는 왜 필요한가?</li><ul><li>오퍼레이션 수행 중에 수정된 페이지들이 버퍼 관리자의 버퍼 교체 알고리즘에 따라서 디스크에 출력될 수 있다.</li><li>즉, 아직 끝나지 않은 트랜잭션이 수정한 페이지들도 디스크에 출력될 수 있다는 의미</li><li>근데, 해당 트랜잭션이 어떤 이유든 정상적으로 종료될 수 없게 되면 트랜잭션이 변경한 페이지들은 원상 복구되어야 하는데, 이때의 복구를 <ins>UNDO 복구</ins>라고 부름</li></ul></ul><br><ul><li>버퍼 관리 정책 - STEAL 정책</li><ul><li><ins>수정된 페이지를 언제 디스크에 쓸 것인가 기준으로 나눌 수 있는 정책</ins></li><li><code>STEAL</code> : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책</li><li><code>~STEAL</code> : 수정된 페이지들을 최소한 트랜잭션 종료 시점(EOT, End of Transaction)까지는 버퍼에 유지하는 정책</li><li>대부분의 상용 DBMS는 STEAL 정책을 채택한다. 이 말은 커밋 이전의 트랜잭션이 디스크에 써질 수 있고 이때문에 UNDO 로깅과 복구가 필요해진다.</li></ul></ul><br><ul><li>REDO는 왜 필요한가?</li><ul><li>ACID 중 Durability 때문에 커밋한 트랜잭션의 경우 어떠한 상황에서도 보존되어야 하기 때문이다.</li><li>이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업을 <ins>REDO 복구</ins>라고 하는데, REDO 복구 역시 UNDO 복구와 마찬가지로 버퍼 관리 정책에 영향을 받음</li></ul></ul><br><ul><li>버퍼 관리 정책 - FORCE 정책</li><ul><li><ins>트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지들을 디스크에도 쓸 것인가 쓰지 않을 것인가로 나눈 정책</ins></li><li><code>FORCE</code> : 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책</li><li><code>~FORCE</code> : 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책</li><ul><li><code>~FORCE</code>는 수정했던 페이지(데이터)를 디스크에 반영하지 않는다는 점이지 커밋 시점에 어떠한 것도 쓰지 않는다는 것은 아니다. 커밋 시점에 어떤 일들을 했었다는 REDO 로그는 기록함</li></ul><li>대부분의 상용 DBMS는 ~FORCE 정책을 채택한다. 이 말은 커밋한 트랜잭션의 내용이 디스크 상의 데이터베이스 상에 반영되어 있지 않을 수 있기 때문에 반드시 REDO 복구가 필요해진다.</li></ul></ul><br><ul><li>결과적으로, DBMS는 버퍼 관리 정책으로 <code>STEAL 정책</code>과 <code>~FORCE 정책</code>을 채택하므로 UNDO 복구와 REDO 복구 모두 필요하고, 이러한 방법으로 데이터베이스 트랜잭션을 관리한다.</li></ul></details>

</details>

<br>

<details><summary>3-3. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요? (출처 : vsfe)</summary>

<br>

- DBMS는 Durability를 보장하기 위해 로그(log)라는 갱신 작업에 대한 기록을 관리하여 보장함
  - 커밋된 트랜잭션에 의해 갱신된 내용이 디스크에 미처 반영되기 전에 시스템 장애가 발생하면, 시스템 재 구동 시에 로그를 판독하여 변경된 내용을 복구

- <ins>WAL (Write-Ahead Logging) : 트랜잭션으로 인한 모든 변경 사항을 커밋하기 전에 로그 파일에 기록</ins>

- <ins>저널링 : 트랜잭션 중에 발생한 모든 변경 사항을 기본 데이터 파일에 쓰기 전에 기록하고 저장하는 프로세스</ins>
  - 데이터베이스에 문제가 발생할 경우 데이터베이스가 불완전한 트랜잭션을 복구하고 롤백할 수 있음

- checkpoint : 메모리 내 데이터베이스 버퍼의 내용을 디스크에 주기적으로 저장하는 작업

- 데이터베이스 백업 : 시스템 오류나 손상이 발생할 경우 데이터 손실을 방지하기 위해 정기적으로 데이터베이스를 백업

- <details><summary>번외. 한국의 DBMS인 알티베이스</summary><ul><li>우리나라의 알티베이스라는 DBMS의 Durability Level을 참조해봐도 좋을 것 같음</li><li><a href="https://dataonair.or.kr/db-tech-reference/d-guide/dbms-1/?mod=document&uid=101732">링크 1</a></li><li><a href="http://www.gurubee.net/lecture/2168">링크 2</a></li></ul></details>

<br>

</details>

<br>

<details><summary>3-4. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요? (출처 : vsfe)</summary>

<br>

- 갱신 작업에 한해서는 스프링을 사용하면서 트랜잭션을 항상 걸었음

- 예를 들어, 모아밤 프로젝트에서 루틴을 인증하는 로직이 있었음. 이 로직은 루틴 인증 버튼을 눌러서 요청을 날렸을 때, 클라이언트에서 이미지를 보내주면 이미지 리사이징 → 이미지 업로드 → 이미지 업로드가 되면 루틴 인증 처리의 로직이 되어있어서, 하나의 논리적인 작업 단위로 묶어야해서 트랜잭션을 사용했음
  - 이미지 업로드 자체를 다른 트랜잭션으로 뺀다고 하더라도 루틴 인증 내부에 반드시 포함되어야 함

</details>

<br>

<details><summary>3-5. 읽기에는 트랜잭션을 걸지 않아도 될까요? (출처 : vsfe)</summary>

<br>

- 일반적으로 읽기 작업만 수행하는 상황에서는 트랜잭션을 걸지 않아도 됨

- 그러나, 여러 사용자나 시스템이 동시에 같은 데이터에 접근할 때, 데이터의 일관성을 유지하기 위해 읽기 작업에 트랜잭션을 걸어야 할 수 있음 (동시성 제어가 필요한 경우)

- 동시성 제어의 상황에서 트랜잭션 격리 수준에 따라 발생할 수 있는 문제
  - Dirty Read : 수정 중이고 커밋되지 않은 데이터를 다른 트랜잭션에서 읽어서 일관성 어긋나는 현상
  - Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때 그 사이에서 다른 트랜잭션이 수정 또는 삭제해서 둘의 결과가 다르게 나타나는 현상
  - Phantom Read : 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상

</details>

<br>

<details><summary>3-6. 트랜잭션의 상태에 대해서 설명해주세요. (창작 문제)</summary>

<br>

<p align="center"><img src="../image/2024.03.20-신재윤-image03.png" height="50%", width="75%"></p>

- 활동(Active)
  - 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태

- 장애(Failed)
  - 트랜잭션이 실행에 오류가 발생하여 중단된 상태

- 철회(Aborted)
  - 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

- 부분 완료(Partially Committed)
  - 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

- 완료(Committed)
  - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

</details>

<br><hr>

## 4번 질의

<details><summary>4-1. 트랜잭션 격리 레벨에 대해 설명해 주세요. (출처 : vsfe)</summary>

<br>

<p align="center"><img src="../image/2024.03.20-신재윤-image02.png" height="50%", width="75%"></p>

- 여러 트랜잭션이 수행될 때, 각 트랜잭션이 얼마나 고립되어 있는지를 나타내는 정도

- 동시성 제어에서 Locking을 통해 다른 트랜잭션이 관여하지 못하도록 막는데, 무조건 Locking을 수행하면 성능이 떨어지기 때문에 이를 고려하여 효율적인 Locking이 필요해진다.

- `Read Uncommitted`
  - Select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않음
  - 트랜잭션 처리중이거나 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
  - 데이터 정합성에 문제가 있어, 사실상 격리수준으로 인정되지 않음(Dirty Read 발생)
  - <details><summary>예시</summary><p align="center"><img src="../image/2024.03.20-신재윤-image04.png" height="50%", width="75%"></p><ul><li>트랜잭션1에서의 변경 사항이 아직 커밋되지 않았음에도, 트랜잭션1 이후에 시작된 트랜잭션2에서 그 변경 사항을 조회할 수 있다.</li></ul></details>

- `Read Committed`
  - Select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸림
  - 트랜잭션이 Commit 되어 확정된 데이터만 읽는 것을 허용
  - 일반적인 SQL 서버의 Default Isolation Level
  - <details><summary>예시</summary><p align="center"><img src="../image/2024.03.20-신재윤-image05.png" height="50%", width="75%"></p><ul><li>트랜잭션1에서 업데이트 쿼리로 인해 레코드의 값이 바뀌었음에도, 트랜잭션2에서 이 레코드를 조회할 때는 트랜잭션1이 커밋되지 않았기 때문에, 백업되어 있는 업데이트 이전의 레코드 값이 조회된다.</li></ul></details>

- `Repetable read`
  - 트랜잭션이 시작되기 전에 Commit된 내용에 대해서만 조회가 가능
  - 자신의 트랜잭션 번호보다 낮은(먼저 일어난) 트랜잭션 번호에서 커밋된 사항만 확인 가능
  - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장
  - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가
  - <details><summary>예시</summary><p align="center"><img src="../image/2024.03.20-신재윤-image06.png" height="50%", width="75%"></p><ul><li>해당 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있다. UNDO 공간에 백업해두고, 그 값을 읽음 (공간에 대한 비용 소모)</li></ul></details>

- `Serializable`
  - 한 트랜잭션을 다른 트랜잭션과 완전히 분리하는 격리 수준
  - 트랜잭션이 완료될 때까지 Select 문장이 사용하는 테이블에 Shared Lock을 검

<br>

- `Dirty Read`
  - 아직 실행이 완료되지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 상황
  - 커밋되지 않은 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생

- `Non-Repeatable Read`
  - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정하거나 삭제하면서 두 쿼리의 결과가 다르게 나타나는 상황
  - <details><summary>예시</summary><p align="center"><img src="../image/2024.03.20-신재윤-image07.png" height="50%", width="75%"></p><ul><li> 트랜잭션2가 끝나기 전에 트랜잭션1이 커밋되면, 하나의 트랜잭션(2번)에서는 똑같은 레코드의 조회(select)를 수행했음에도, 다른 결과를 조회하게 되는 문제가 생길 수 있다. (일관성 오류)</li></ul></details>

- `Phantom Read`
  - 하나의 트랜잭션에서 일정 범위의 같은 쿼리를 두 번 실행했을 경우, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 상황, 첫 번째 쿼리에서 있던 레코드가 두 번째 쿼리에서 사라지는 상황
  - <details><summary>예시</summary><p align="center"><img src="../image/2024.03.20-신재윤-image08.png" height="50%", width="75%"></p><ul><li> 하나의 트랜잭션에서 일정 범위에 대한 같은 쿼리를 두 번 실행했을 때, 첫 쿼리에서는 없던 유령 레코드가 두 번째 쿼리에서는 나타나는 현상이 일어날 수 있다.(결과 집합이 달라짐) 범위 전체에 대해서는 보관하지 못하기 때문에 발생하는 문제</li></ul></details>

</details>

<br>

<details><summary>4-1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요? (출처 : vsfe)</summary>

<br>



</details>

<br>

<details><summary>4-1. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요. (출처 : vsfe)</summary>

<br>



</details>

<br>

<details><summary>4-1. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요? (출처 : vsfe)</summary>

<br>



</details>

<br><hr>

## 11번 질의

<details><summary>11-1. DB Locking에 대해 설명해 주세요. (출처 : vsfe)</summary>

<br>



</details>

<br>

<details><summary>11-1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요. (출처 : vsfe)</summary>

<br>



</details>

<br>

<details><summary>11-1. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요? (출처 : vsfe)</summary>

<br>



</details>

<br><hr>

## 참고자료

- vsfe 님의 **[VSFE / Tech-Interview Github](https://github.com/VSFe/Tech-Interview/tree/main)**
- 유튜버 쉬운코드 님의 **[데이터베이스 트랜잭션을 아십니까?](https://www.youtube.com/watch?v=sLJ8ypeHGlM)**
- 네이버 d2 **[DBMS는 어떻게 트랜잭션을 관리할까?](https://d2.naver.com/helloworld/407507)**
- livvjh 님의 **[쉽게 이해하는 MySQL 아키텍처 한판 정리](https://livvjh.com/posts/develop/real-mysql-architecture/)**
- devjem 님의 **[네이버 d2 트랜잭션 아티클 정리 글](https://devjem.tistory.com/73)**
- AppMaster **[데이터베이스 트랜잭션을 관리하고 ACID 속성을 구현하는 방법](https://appmaster.io/ko/blog/deiteobeiseu-teuraenjaegsyeon-mic-sanseong-sogseong)**
- R팀 스터디 **[트랜잭션](https://github.com/prgrms-web-devcourse/BE-Team-R-CS-Study/blob/main/Database/2022-04-08-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.md)**