# 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해주세요.

**트랜잭션**

- 데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 단위

**ACID**

- `Atomicity 원자성` : 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다.
- `Consistency 일관성` : 트랜잭선이 진행되는 동안에 데이터베이스가 변경되더라도 처음에 참조한 데이터베이스로 트랜잭션을 수행해야 한다.
    - 업데이트된 데이터베이스는 사용하지 않는다.
- `Islation 고립성` : 둘 이상의 트랜잭션이 동시에 실행되고 있는 경우, 각각 다른 트랜잭션의 연산에 끼어들 수 없다.
    - 이 트랜잭션이 완료될 때까지 다른 트랜잭션은 이 트랜잭션의 결과를 참조할 수 없다.
- `Durability 지속성` : 트랜잭션이 성공적으로 완료되었을 때, 영구적으로 반영 되어야한다.

### 1) **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**

**Redo**는 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업이다. 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 **FORCE** 버퍼관리 정책과 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 **¬FORCE** 정책 중 채택할 수 있다. Force 정책을 따르면 트랜잭션이 커밋되면 디스크 상의 데이터베이스에 변경사항이 반영되기 때문에 REDO 복구작업이 필요없지만, ¬FORCE 정책을 따르면 커밋한 내용이 디스크 상의 데이터베이스에 반영되지 않았을 수도 있기 때문에 반드시 REDO 복구가 필요하다.

거의 모든 DBMS가 ¬FORCE 정책을 채택한다.

### 2) 트랜잭션 사용 경험? 어떤 경우에 사용 가능?

- 하나의 엔티티에 여러 작업이 동시에 수행될 가능성이 있을 때 사용하는 것이 좋다.
- 작업이 한번에 반영되야되는 것을 보장해야 할 때
    - EX 은행 입출금

### 3) 읽기에는 트랜잭션을 걸지 않아도 될까요?

읽기 연산만 일어나면 데이터의 변경이 일어나지 않기 때문에 동시에 읽어도 문제가 생기지 않는다.

1. Dirty Read
    1. 수정 중이고 커밋되지 않은 데이터를 다른 트랜잭션에서 읽게 되어 일관성에 어긋난다.
2. Non-Repetable Read
    1. 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에서 다른 트랜잭션이 수정 또는 삭제해서 둘의 결과가 다르게 나타나는 현상이 발생 할 수 있다.
3. Phantom Read
    1. 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상

# 트랜잭션 격리 레벨에 대해서 설명해주세요.

1. `Read Uncommitted` 레벨 0
- 아예 격리가 되지 않는 레벨
- 트랜잭션에 처리 중이거나, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있는 격리 수준이라, DB 일관성을 유지할 수 없다.
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는다.
- 이 격리수준에서는 Dirty Read, Non-repeatable Read, Phantom Read 현상이 발생할 수 있다.
1. `Read Committed` 레벨 1
- 커밋된 데이터만 읽기 허용
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기한다.
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸린다.
- 이 격리 수준에서는 Non-Repeatable Read, Phantom Read 현상이 발생할 수 있다.
1. `Repeatable Read`
- 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때 까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허
- SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸린다.
- Phantom Read 현상이 발생할 수 있다.
1. `Serializable`
- 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱싱하거나 삭제하는 것을 불허하는것 뿐 아니라, 새로운 레코드를 삽입하는 것도 막아 완벽한 읽기 일관성을 보장
- 트랜잭션이 완료될 때까지 SELECT문이 사용되는 모든 데이터에 Shared Lock이 걸린다.
- 일반적으로 레벨이 높아질 수록 트랜잭션 간 고립 정도가 높아지는 동시에 성능이 저하된다.

### **1) 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**

아니요, Read Uncommited 레벨과 같은 경우 거의 필요 없음, Repeatable Read은 오라클의 경우 다중 버전 기반의 읽기 일관성 매커니즘에 의해 Serializable이 효과적으로 지원되어 포함되지 않았다.

> 다중 버전 읽기 일관성
> 
> - 데이터를 읽을 때 록에 의해 록이 풀리기를 기다리는 것이 아니라 이전 버전의 정보를 읽음으로서 쓰기 트랜잭션이 읽기 작업을 막지 않는다.
- 오라클
    - 오라클은 Read Committed 레벨1을 사용한다.
    - Read Committed락을 사용하지 않고 쿼리 시작 시점의 Undo 데이터를 제공하는 방식으로 구현한다.
- MySQL
    - InnoDB 스토리지 엔진은 Repeatable Read 레벨2를 사용한다.

### 2) Undo 영역과 Redo 영역에 대해 설명해 주세요.

- **Redo Log**
    - DB 장애시 복구에 사용되는 로그
    - Buffer Pool에 저장되어 있던 데이터의 유실을 방지하기 위해 사용된다.
        - **Buffer Pool**: InnoDB 엔진이 테이블 캐싱 및 인덱스 데이터 캐싱을 위해 이용하는 메모리 공간. 버퍼풀의 메모리 공간이 클수록 캐싱되는 데이터가 늘어나서 디스크에 접근하는 횟수가 줄어들고, DB 성능 향상으로 이어진다. 하지만 버퍼풀은 메모리 공간이라서 MySQL 장애 발생시 안의 내용은 사라지고, 장애가 복구되더라도 데이터는 복구될 수 없다.
    - 데이터 변경시에 모든 것을 기록한다.
- **Undo Log**
    - 실행 취소 로그 레코드의 집합으로, 트랜잭션 실행 후 롤백시 이전 데이터로 복구할 수 있도록 해놓은 영역
    - 변경되기 전의 데이터와 PK값을 저장.

### 3) 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?

- 데이터베이스에 대해 삽입, 추출, 업데이트 및 삭제하는 데 사용하는 기본 소프트웨어 컴포넌트
- MySQL은 크게 **서버 엔진**과 **스토리지 엔진** 두가지 구조로 구성되어 있다.
    - 서버 엔진은 클라이언트의 쿼리 요청을 받아 쿼리 파싱과 스토리지 엔진 데이터를 요청하는 작업을 수행한다.
    - 스토리지 엔진은 물리적 저장장치에서 데이터를 읽어온다.

# 11. DB Locking에 대해 설명해 주세요.

- DB Locking은 동시성 제어와 연관이 있다.
- 동시성 제어는 DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용에서 DB를 보호한다.
- 동시성을 허용하면 일관성이 낮아지는 편이다.
- 다수 사용자의 동시 접속을 위해 DBMS는 Lock 기능과 SET Transatcion 명령어로 동시성을 제어한다.
- 동시성을 제어하는 방법에는 낙관적 동시성 제어와 비관적 동시성 제어가 있다.

### DB Locking 종류

비관적 동시성 제어를 위한 대표적인 방법은 Lock이다. 락은 트랜잭션 처리의 순차성을 보장한다.

- 공유락 (Share Lock) : 읽기 잠금
    - 공유락끼리는 동시에 접근이 가능하다.
    - 여러 사용자가 동시에 하나의 데이터를 읽을 수 있다.
    - 공유락이 설정된 데이터에 배타락을 걸 수는 없다.
- 배타락 (Exclusive Lock) : 쓰기 잠금
    - 데이터를 변경하고자 할 때 사용한다.
    - 락이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.
    - 해당 락은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 락을 설정할 수 없다.

### 락 사용시 유의사항

> 블로킹: 락(배타-배타, 배타-공유)의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춘 상태
> 
1. 한 트랜잭션의 길이가 너무 길면 경합이 발생할 확률이 올라간다
2. 처음 설계부터 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 주의한다
3. 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다
4. 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행한다

데드락이 발생할 수 있으니 유의하자

### 1) **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**

- `낙관적 동시성 제어 (Optimistic Concurrency Controll)`
    - 낙관적 락은 일반적으로 충돌이 발생할 것으로 예상하지 않는 상황에서 사용됩니다.
    - 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정해서 데이터를 **읽는 시점에 락을 걸지 않는다.**
    - 대신에 수정 시점에 값이 변경 됐는지를 검사한다.
    - 주로 낙관적 락은 버전 관리나 변경 추적을 통해 구현됩니다. 예를 들어, 데이터의 버전 번호를 사용하여 동시성 충돌을 감지할 수 있습니다.
- `비관적 동시성 제어 (Pessimistic Concurrency Control)`
    - 비관적 락은 충돌이 발생할 것으로 예상되는 상황에서 사용된다.
    - 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정해서 데이터를 **읽는 시점에 락**을 걸고, 트랜잭션이 완료될 때까지 락을 유지한다.
    - 락을 통해 업데이트를 제어하기 때문에 데이터 정합성이 보장됨.
    - Select 시점에 락을 거는 비관적 동시성 제어는 시스템의 동시성을 심각하게 저하 시킬 수 있어서 wait/nowait 옵션과 함께 사용해야 한다.

### 2) 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

- 데드락 탐지 및 해결
    - DB 시스템은 데드락을 탐지하고 해결하기 위한 메커니즘을 제공한다.
    - 데이터베이스 시스템은 주기적으로 데드락을 탐지하고 해결함으로써 이를 방지할 수 있습니다. 이를 통해 락이 영구적으로 해제되지 않는 상황을 방지할 수 있습니다.
- 타임아웃 설정
    - 특정 시간동안 트랜잭션이 락을 획득하지 못한 경우, 락이 자동으로 해제되어 데드락 상황 방지할 수 있다.
- MVCC
    - 데이터베이스 시스템에서 동시성 제어를 위해 사용되는 기술입니다.
        - MVCC에서 데이터에 접근하는 사용자는 접근한 시점에 데이터베이스의 스냅샷을 읽는다.
        - 이 스냅샷 데이터에 대한 변경은 다중 버전 상태로 유지되어 커밋 전까지는 스냅샷을 undo 영역에 유지하고 있다.
        - 그래서 다른 트랜잭션은 undo 영역을 참조하여 데이터를 사용한다.
    - MVCC는 동시에 여러 트랜잭션이 데이터에 접근할 때 발생할 수 있는 문제를 해결하기 위해 도입되었습니다.
    - 주로 대부분의 현대적인 관계형 데이터베이스 시스템에서 사용됩니다.
    - MVCC는 다중 버전을 사용하여 동시성을 제어하는 방식으로, 락을 최소화하고 동시성을 향상 시킨다.
    - MVCC 사용시 락을 걸지 않고도 데이터에 접근할 수 있으며, 이는 락이 비정상 종료로 인해 영구적으로 유지되는 문제를 해결할 수 있다.
