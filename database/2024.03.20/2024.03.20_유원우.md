# 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

**트랜잭션**: 논리적인 단일 작업 단위, 여러 SQL문들을 단일 작업으로 묶어 나누어질 수 없게 만드는 것   

**ACID**:   
Atomicity: ALL or NOTHING 으로 트랜잭션은 논리적으로 쪼개질 수 없는 작업 단위기 때문에 모두 성공해야 한다. 만일 중간에 SQL문이 실패하면 지금까지의 작업을 모두 취소하여 아무 일도 없었던 것처럼 `rollback` 해야 한다.   
Consistency: 트랜잭션이 데이터베이스의 일관된 상태(제약 사항을 모두 지키는 상태)에서 다른 일관된 상태로 바꿔줘야 한다. 만일 일관된 상태가 깨진다면 rollback 해야 한다. DBMS의 일관성은 DBMS가 확인하지만 애플리케이션 관점에서의 일관성은 개발자가 챙겨야 한다.   
Isolation: 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 서로 영향을 미치지 않도록 보장해야 합니다. 격리 수준과 상황에 따라서 Isolation를 지킬 수도 지키지 못할 수 있습니다. 격리 수준이 높다면 Isolation을 지킬 가능성이 높아지지만 동시성이 감소하여 시스템의 전반적인 성능에 영향을 줄 수 있습니다.   
Durability(영존성): 커밋된 트랜잭션은 시스템 장애(power fail, DB crash)가 발생해도 DB에 남아있어야 합니다. DBMS는 트랜잭션 로그, 복구 메커니즘을 통해 이를 보장합니다.

## ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

DBMS는 모든 변경 사항을 트랜잭션 로그에 기록합니다. 이 로그는 주 메모리가 아닌 영구 저장소에 저장합니다. 트랜잭션이 커밋되는 순간 관련 변경 사항이 로그에 기록되어 있으므로 시스템 장애가 발생해도 이 로그를 통해 데이터를 복구할 수 있습니다.

## 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

쇼핑몰 시스템에서 사용자가 상품을 주문하는 과정에서 사용해본 경험이 있습니다. 사용자의 주문 정보 저장, 재고 수량 감소, 결제 처리 등의 일관성을 지켜야 하여 사용하였습니다.

## 읽기에는 트랜잭션을 걸지 않아도 될까요?

읽기 연산에서도 트랜잭션을 사용해야 할 수 있습니다. 반복해서 같은 데이터를 읽을 때 매번 동일한 데이터(동일한 행, 동일한 행의 수) 읽는 것이 보장되어야 한다면 트랜잭션을 사용할 수 있습니다.   
**Nonrepeatable Read**: 같은 데이터를 두 번 읽었을 때 첫 번째 읽기와 두 번째 읽기 사이에 읽기 결과가 다른 경우, 한 트랜잭션이 고객의 계좌 잔액을 조회한 후, 다른 트랜잭션이 해당 계좌의 잔액을 변경하고 첫 번째 트랜잭션이 다시 잔액을 조회했을 때 변경된 잔액을 보게 된 경우   
**Phantom Read**: 한 트랜잭션 내에서 수행된 두번의 범위 쿼리 결과가 서로 다를 경우, 첫 번째 쿼리 실행 후 다른 트랜잭션이 새로운 행을 삽입하거나 삭제함으로써 두 번째 쿼리의 결과에 이전에는 없던 '팬텀' 행이 나타나거나 사라지는 경우

# 트랜잭션 격리 레벨에 대해 설명해 주세요.

|Isolation level|Dirty read|Non-repeatable read|Phantom read|
|---            |---       |---                |---         |
|Read uncommited|O         |O                  |O           |
|Read commited  |X         |O                  |O           |
|Repeatable read|X         |X                  |O           |
|Serializable   |X         |X                  |X           |

**SnapShot isolation**: 트랜잭션을 시작할 때 스냅샷을 캡쳐해서 실행되는 동안 스냅샷을 기준으로 데이터를 읽습니다. 변경 연산도 스냅샷에 수정하고 커밋시에 데이터베이스에 반영합니다.   

**dirty write**: 커밋이 안된 데이터를 write하였다가 롤백한 경우, 중간에 커밋된 데이터까지 롤백되는 현상   
**lost update**: 업데이트를 덮어씌워서 중간에 업데이트 커밋된 데이터가 반영되지 않는 현상
**dirty read**: 커밋되지 않은 데이터를 읽어 발생하는 문제   
**read skew**: inconsistent한 데이터를 읽는 현상, non-repeatable read와 비슷하지만 일관성이 깨진 데이터가 추가됨   
**write skew**: inconsistent한 데이터를 쓰는 현상, 다른 트랜잭션이 각자 상황에서는 consistent하지만 결과가 합쳐졌을 때는 inconsistent한 현상   
**phantom read**: 한 트랜잭션 내에서 수행된 두번의 범위 쿼리 결과가 서로 다를 경우, 추가로 연관 데이터가 변경된 경우에도 해당함(예시: 레코드가 추가될 때마다 count를 증가한다고 가정하면, 1번 트랜잭션이 처음 count를 read할 땐 0이었지만 두번째 read할 때는 1일 수도 있는 현상)


## 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?

4개의 레벨을 모두 구현하고 있지 않습니다. 4개의 레벨은 표준일 뿐 상용 DBMS가 따를 필요는 없다고 생각합니다.

## 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

**Undo**: 이전 데이터 상태를 보존합니다. 롤백, 일관된 읽기를 지원합니다.
**Redo**: 트랜잭션의 모든 변경 사항을 기록합니다. 시스템이 예기치 않게 실패해도 이 로그를 통해 데이터베이스를 안전하게 복구할 수 있습니다.   
Redo 로그가 너무 작으면 자주 로그를 갱신해야 하고 큰 경우 복구 시간이 길어질 수 있습니다. Undo 로그의 경우에도 마찬가지

## 스토리지 엔진이 정확히 무엇을 하는 건가요?

DBMS에서 저장, 조회, 업데이트 및 관리하는 방식을 정의하는 소프트웨어 구성요소입니다. 이는 물리적인 데이터 구조와 데이터 접근 방법을 결정합니다. InnoDB의 경우 트랜잭션, 외래키 제약조건, 동시성 제어 등 기능을 제공합니다.

# DB Locking에 대해 설명해 주세요.

여러 트랜잭션를 사용함에 있어 발생할 수 있는 이상현상으로부터 Consistency와 Isolation을 유지시켜줍니다. 대표적으로 shared lock과 exclusive lock이 있습니다.

## Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.

**Optimistic Lock**: 동시성 문제가 자주 발생하지 않을 것을 가정하여 데이터 변경시에만 검사하는 방식입니다. 변경이 감지되면 애플리케이션에서 트랜잭션을 실패하고 충돌을 해결하기 위한 조치를 취해야 합니다.
**Pessimistic Lock**: 동시성 문제가 일어날 것을 예상하여 데이터의 접근을 미리 제한하는 방식입니다. 데드락 발생 가능성이 있습니다.

## 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

DBMS가 트랜잭션 롤백시에 자동적으로 락 할당을 풉니다. 너무 오랫동안 복구되지 않을 것을 감안하여 LOCK 할당 시간을 줄 수 있을 것 같습니다.