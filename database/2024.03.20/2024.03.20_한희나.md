# 데이터베이스
## 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
트랜잭션은 하나의 작업을 위해 더 이상 분할될 수 없는 명령들의 모음이다.
트랜잭션의 특징은 크게 4가지로 구분된다.
- 원자성(Atomicity) 
  - 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다
- 일관성(Consistency)
  - 트랜잭션의 작업 처리 결과가 항상 일관성 있어야 한다
- 독립성(Isolation)
  - 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다
- 영구성(Durability)
  - 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다
### ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
대부분의 데이터베이스는 데이터 변경 내용을 로그로 먼저 기록한다. 
데이터베이스는 쓰기 비용이 낮은 자료 구조를 가진 리두 로그를 가지고 있으며, 비정상 종료가 발생하면.
리두 로그 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.
데이터베이스는 성능을 위해 리두 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료 구조도 가지고 있다.
MySQL 서버가 비정상 종료되어 일관되지 않는 데이터 가질 경우 리두 로그와 언두 로그를 이용해 복구한다.

- 커밋됐지만 데이터 파일에 기록 안됨 → 리두 로그에 데이터 복사
- 롤백됐는데 데이터 파일에 기록됨 → 언두 로그에서 변경되기 전 데이터 가져와 복사
### 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
논리적인 작업 셋을 100% 적용되거나 아무것도 적용되지 않아야 할때 트랜잭션을 적용한다.
트랜잭션은 애플리케이션 개발에서 고민해야할 문제를 줄여준다. 만약 트랜잭션이 없다면, 부분 업데이트 현상이 발생할 때 남은 레코드를 삭제하는 재처리 작업이 필요하다.
프로그램 코드에서 트랜잭션 범위를 최소화해야 한다. 메일 전송이나 FTP 파일 전송 또는 네트워크를 통해 원격 서버와 통신하는 작업은 트랜잭션 내에서 제거하는 것이 좋다.
### 읽기에는 트랜잭션을 걸지 않아도 될까요?
읽기 전용 트랜잭션(Transaction Read Only)은 Read-Write보다 성능이 좋으며 DBMS마다 동작 방식이 다르다. MySQL의 경우 읽기 전용 트랜잭션에 대해서는 ID가 부여되지 않아 TRX_ID 필드에 대한 오버 헤드가 줄어든다. 
## 4. 트랜잭션 격리 레벨에 대해 설명해주세요.
트랜잭션 격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회되는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
격리 수준은 크게 READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALIZABLE의 4가지로 나뉜다. 뒤로 갈 수록 트랜잭션 간의 데이터 격리 정도가 높아지며 동시처리 성능도 떨어지는 것이 일반적이다. MySQL의 경우 SERIALIZABLE 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않는다. 온라인 서비스 용도의 데이터베이스는 READ COMMITED, REPEATABLE READ 중 하나를 사용한다. 
- READ UNCOMMITED
  - 트랜잭션의 변경 내용이 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 보인다.
  - 어떤 트랜잭션에서 처리한 작업이 완료되지 않았음에도 다른 트랜잭션에서 볼 수 있는 형상인 더티 리드(Dirty read)가 발생한다.
  - 정합성에 문제가 많다.
- READ COMMITED
  - 오라클에서 기본으로 사용되는 격리 수준이다.
  - 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. 
  - 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행하였을 때 항상 같은 결과를 가져오지 않는 NON-REPEATABLE READ 부정합 문제가 발생한다.
- REPEATABLE READ
  - MySQL InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.
  - MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션에서 동일한 결과를 보여준다.
  - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상인 PHANTOM READ가 발생한다. 다만 InnoDB에서는 이러한 부정합 현상이 발생하지 않는다.
- SREIALIZABLE
  - 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못한다. 결국 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 접근할 수 없다.

### 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
DBMS마다 격리 수준 구현은 모두 다르고, 같은 수준이더라도 내부 구현이 다르다.
격리 수준이 높을 수록 트랜잭션 처리 과정에서 제약이 발생해 처리량이 감소한다. 따라서 작업에 따라 처리량과 데이터의 일관성을 타협하여 레벨을 설정해야 한다. 
### 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해주세요
- Undo 영역
  - InnoDB는 MVCC를 언두 로그로 구현하고 있으며 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
- Redo 영역
  - 리두 로그는 버퍼 풀에서 변경된 데이터를 가진 더티 페이지(Dirty Page)에서 변경분만 가지고 있다. InooDB는 주기적으로 리두 로그와 더티 페이지를 디스크로 동기화 한다.
  - 영속성과도 관련 있는데, 리두 로그는 쓰기 비용이 낮은 자료구조로 트랜잭션이 커밋되면 즉시 리두 로그 파일(디스크)에 기록된다.
### 스토리지 엔진이 정확히 무엇을 하는 건가요?
실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지 부터 데이터를 읽어오는 부분을 전담한다.
## 11. DB Locking에 대해 설명해 주세요.
같은 자원(데이터)에 대해 동시에 접근할 때, 데이터는 일관성과 무결성을 유지해야 한다. 그래서 잠금을 통해 트랜잭션 처리의 순차성을 보장함으로써 유지한다.
잠금은 크게 공유 잠금(Shared Lock)과 배타 잠금(Exclusive Lock)로 나뉜다.
- 공유 잠금
  - 데이터를 읽을 때 사용되는 잠금이다.
  - 공유 잠금끼리 동시에 접근이 가능하지만, 공유 잠금이 설정된 데이터에 배타 잠금은 사용할 수 없다. 즉, 공유 잠금을 걸었을 경우 다른 세션이 동일한 데이터를 읽을 수는 있지만 변경할 수는 없다.
- 배타 잠금
  - 데이터를 변경할 때 사용되며 트랜잭션이 완료될 때까지 유지된다. 배타 잠금은 잠금이 해제될 때까지 다른 트랜잭션은 해당 데이터에 읽기와 쓰기 작업을 할 수 없다.
### (추가) 잠금에서 블로킹과 교착 상태 문제가 발생할 수 있습니다. 블로킹과 교착 상태란 무엇이고 어떻게 해결할 수 있는지 설명해 주세요.
- 블로킹
  - 잠금들의 경합(race condition)이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰선 상태를 의미한다. 
  - 블로킹은 공유 잠금 - 배타 잠금, 배타 잠금 - 배타 잠금끼리 발생할 수 있다. 이를 해결하기 위해서는 이전의 트랜잭션이 커밋 또는 롤백이되어야 한다. 
  - 블로킹은 트랜잭션이 길어지는 문제가 발생하므로 성능에 좋지 않다. 따라서 블로킹을 최소화해야 한다.
- 블로킹 최소화 방법
  - SQL문이 빠르게 실행되도록 리팩터링해야 한다. 이것이 가장 기본적이고 효과적인 방법이다.
  - 트랜잭션을 가능한 짧게 정의한다.
  - 동일한 데이터를 변경하는 트랜잭션이 동시에 수행되지 않도록 한다.
  - 대용량 작업 시, 작업 단위를 쪼개거나 lock_timeout을 설정한다.
- 교착 상태(dead lock) 
  - 두 트랜잭션이 각각 잠금을 설정하고 서로의 잠금에 접근하려 할 때, 이미 각각의 트랜잭션에 잠금이 설정되어 있기 때문에 양쪽 트랜잭션 모두 처리되지 않는 상태를 말한다.
- 교착 상태 해결 방법
  - 트랜잭션 진행 방향을 같은 방향으로 설계한다. (테이블 접근 순서가 동일하다던가)
  - 트랜잭션 처리 속도를 최소화한다
  - set_lock_timeout문을 사용하여 잠금 해제 시간을 조절한다.
### Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
- 낙관 락 
  - 애플리케이션 레벨에서 잡아주는 락
  - version 등의 구분 컬럼을 이용해서 충돌 예방한다.
  - 같은 레코드에 대해서 각기 다른 2개의 수정 요청이 있지만 1개가 업데이트 됨에 따라 버전이 변경되었기 때문에 뒤의 수정 요청은 반영되지 않는다.
  - 충돌이 났으면 개발자가 수동으로 롤백 처리를 해줘야 한다. 따라서 충돌이 많이 예상되거나 충돌이 발생했을 때 비용이 많이 들것이라고 판단되면 사용하지 않아야 한다.
  - 성능적으로 비관락보다 낙관락 더 좋다. 비관 락은 충돌이 발생할 것이라 생각하고 바로 락을 걸어버리기 때문이다. 
- 비관 락
  - 트랜잭션이 시작될 때 공유 락, 배타 락을 걸고 지작한다. 
### (추가) DB 잠금을 사용하지 않았는데 잠금이 걸리는 경우가 있습니다. 어떤 상황인가요?
외래키 제약 조건이 있는 테이블은 변경 시 부모 테이블이나 자식 테이블에 데이터가 존재하는지 체크하는 작업이 필요하다. 따라서 잠금이 연관관계를 맺고 있는 여러 테이블로 전파되고, 해당 변경 작업을 위해 외래키 칼럼에 공유 잠금이 걸리게 되면서 데드락이 발생한다.
외래키 제약 조건이 있는 테이블에는 낙관 락을 활용해도 데드락은 피할 수 없고 이를 해결하기 위한 비관 락을 사용한다.
### (추가) InnoDB 스토리지 엔진의 잠금은 무엇인가요?
레코드 기반의 잠금 기능을 제공하며 레코드 락, 갭 락, 넥스트 키 락이 있다.
레코드 자체만은 잠금은 레코드 락, 레코드와 바로 인접한 레코드 사이의 간격만을 잠근 갭 락, 레코드 락 + 갭락을 합쳐놓은 형태의 넥스트 키 락이 있다.
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
### (추가) MySQL의 자동 증가 락은 무엇인가요?
auto_increment 칼럼이 사용된 테이블에 동시에 여러 레코드가 insert 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야한다.
InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 auto_increment 락이라고 하는 테이블 수준의 잠금을 사용한다.
auto_increment 락은 트랜잭션과 관계없이 insert나 replace 문장에서 auto_increment 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다. auto_increment 락을 명시적으로 획득하고 해제하는 방법은 없다. 락은 아주 짧은 시간 동안 걸렸다가 해제되는 잠금이라 대부분의 경우 문제가 되지 않는다. 
### 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
테이블 잠금은 잠금의 대상이 테이블 자체이므로 쉽게 문제의 원인이 발견되고 해결될 수 있다. 하지만 레코드 수준의 잠금은 그 레코드가 사용되지 않는다면 오랜 시간 잠겨진 상태로 남아 잘 발견되기 어렵다. 
MySQL의 경우 5.1 버전부터 레코드 잠금과 잠금 대기에 대한 조회가 가능하다. 강제로 잠금을 해제하려면 KILL 명령을 이용해 MySQL 서버의 프로세스를 강제로 종료하면 된다.