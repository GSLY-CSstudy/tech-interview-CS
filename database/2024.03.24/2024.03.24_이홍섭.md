# 5. 인덱스란? 언제 사용?

- 추가적인 쓰기 작업과 저장 공간을 활용해 DB 테이블의 탐색 속도를 향상 시키기 위한 자료구조
- 컬럼에 대해 색인을 부여해 빠르게 탐색이 가능하다.
    - 데이터 조회/수정/삭제의 성능이 향상된다.
- 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
- **규모가 큰 테이블, 수정이 적은 컬럼, 조회가 잦은 컬럼, 데이터 중복이 낮은 컬럼이 효율적**

### 1) 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?

- 인덱스는 항상 정렬된 상태로 유지해야 하기 때문에 수정을 할 경우 인덱스를 추가하거나 인덱스를 사용하지 않는다는 처리 등의 추가적인 작업이 필요하기 때문에 성능이 낮아진다.
    - 인덱스를 수정할 때마다 해당 인덱스를 **재구성해야** 하므로 **오버헤드가** 발생합니다.
- `INSERT` : 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 저렬하여 저장하기 때문에 성능 저하가 발생한다.
- `DELETE` : 테이블에서만 삭제되고 인덱스 테이블에는 남아 있어서 쿼리 수행 속도가 저하 된다.
- `UPDATE` : 인덱스에는 UPDATE가 없어서 DELETE, INSERT 두 작업을수행하여 부하가 발생한다.
- 수정이 잦으면 실제 데이터보다 인덱스의 크기가 너무 커져 부하가 발생

### 2) 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?

- 인덱스를 사용하지 않는다고 선택한 값은 위 정책을 그대로 따르지는 않습니다.
- 수정이 잦은 테이블에서 인덱스를 사용하지 않는 것은 성능 이슈를 방지하기 위한 것이며, 이는 선택적인 결정입니다.
- 따라서 다른 성능 최적화 방법을 고려하고 적절한 경우 인덱스를 사용하지 않는 것이 더 나을 수 있습니다.
- 개발자는 특정 상황에 따라 최적의 결정을 내리고, 이를 효과적으로 관리해야 합니다.

### 3) **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**

**`ORDER BY`** 

- 인덱스 O : 인덱스가 있다는 것은 인덱스 컬럼을 기준으로 정렬되어 있다는 것이므로, 별도의 정렬을 위한 처리가 필요없다.
- 인덱스 X : **Filesort** 방식으로, 레코드를 읽어온 후 MySQL 서버에서 SortBuffer 라는 메모리 공간을 활용해 정렬한다.
    - Sort Buffer의 크기는 가변적으로 증가하고 최대 사이즈는 시스템 변수 `sort_buffer_size`로 설정할 수 있다.

`**GROUP BY**`

- 인덱스 O : 인덱스가 있다는 것은 인덱스 컬럼을 기준으로 정렬되어 있다는 것이므로, 별도의 정렬을 위한 처리가 필요없다.
- 인덱스 X : 인덱스를 사용할 수 없을 때는 **임시 테이블**을 사용한다.
    
    > 임시 테이블을 사용하여 처리될 때는 Extra 컬럼에 "Using temporary" 메시지가 나타난다
    > 

### 4) 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?

- 일반적으로 PK가 자동으로 인덱스 적용이 되지만, PK ≠ 인덱스
- PK는 개념적인 값으로 레코드의 유일성을 보장하지만 물리적으로 **저장 X**
- 반면 인덱스는 레코드의 유일성을 보장하지 않고, 단지 탐색을 빠르게 해주는 역할이다.
    - 그리고 별도의 디스크 공간에 저장된다.

### 5) 그렇다면 외래키는요?

- DB에 따라 다름, innoDB인경우 생성

### 6) 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?

- 인덱스는 데이터의 **논리적 구조**를 나타내는 구조이며, 데이터 자체의 **물리적 저장 방식**을 결정하지는 않습니다.
- 일반적으로 DBMS는 다음과 같은 방식 중 하나를 사용하여 데이터를 저장합니다.
    - **힙 (Heap):** 데이터가 추가되는 순서대로 저장됩니다. 삽입 작업은 빠르지만, 특정 값을 찾는 데 시간이 오래 걸릴 수 있습니다.
    - **B-트리 (B-Tree):** 데이터가 균형 잡힌 트리 구조로 저장됩니다. 삽입, 삭제, 검색 작업 모두 효율적으로 수행할 수 있습니다.
    - **해시 테이블 (Hash Table):** 데이터의 특정 값을 기반으로 해시 함수를 사용하여 저장 위치를 결정합니다. 특정 값을 빠르게 찾는 데 효율적입니다.

### 7) **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**

- MongoDB
    - 기본적으로 B-트리 인덱스를 사용하지만, 풀 텍스트 인덱스, 지리적 인덱스 등 다양한 유형의 인덱스를 제공
- Redis
    - 레디스의 내부 인덱싱 기능은 주로 키에 대한 검색에 사용
    - 레디스는 키를 사용하여 데이터를 조회하므로, 키의 빠른 검색을 위해 내부적으로 해시(Hash) 테이블을 사용합니다.
    - 이 해시 테이블은 O(1)의 시간 복잡도로 키에 대한 조회를 수행할 수 있도록 합니다.
- RDB와 SQL 인덱스 차이
    - RDB는 B-트리와 같은 구조를 사용하여 인덱스를 관리하며, NoSQL은 데이터베이스 종류에 따라 다양한 인덱스 구조를 사용합니다.

# 10. B-Tree와 B+Tree에 대해 설명해 주세요.

### B-Tree (Balanced-Tree)

- 균형 트리이다.
- 루트로 부터 리프까지의 **거리가 일정한** 트리 구조라는 뜻
- 일반적트리를 사용했을 때 발생할 수 있는 편향 트리를 방지하기 위해 나옴
- O(logN)을 보장
- 장점 : 데이터 검색의 속도가 빠르다
- 단점 : 트리 노드가 수정되어야 하면 재정렬이 필요
- **루트(root) 노드**
    - 최상단에 위치한 노드
- **리프(leaf) 노드**
    - 자식이 없는 최하단에 위치한 노드
- **내부(internal) 노드**
    - 루트노드와 리프노드를 제외한 모든 노드
- 검색 과정
    1. 루트 노드부터 탐색
    2. 노드의 key를 순회하여 목표 데이터가 존재하면 탐색 종료
    3. 목표 데이터가 존재하지 않으면 어떤 이웃한 두 key 사이에 목표 데이터가 들어가는 경우 사이의 포인터를 통해 자식노드로 내려간다.
    4. 리프 노드까지 2~3번 과정을 반복한다.
- key 삽입 과정
    1. 빈 트리인 경우 루트 노드를 만들어 삽입한다. 루트 노드가 찬 경우에는 노드를 분할해 리프 노드를 생성한다
    2. K가 들어갈 리프 노드를 검색 과정과 동일하게 탐색한다
    3. 해당 리프 노드에 자리가 남으면 정렬을 유지하도록 알맞은 위치에 삽입하고, 차있으면 K를 삽입한 후 해당 노드를 분할한다
    4. 노드가 분할되는 경우면 노드의 중앙값을 기준으로 분할한다. 중앙값은 부모 노드로 합쳐지거나 새로운 노드로 생성된다. 중앙값을 기준으로 왼쪽 키는 왼쪽 자식, 오른쪽 키는 오른쪽 자식으로 생성된다.

### B+Tree

- 모든 리프 노드들은 **링크드 리스트** 형태로 이어져있다.
- **실제 데이터는 리프 노드에만 저장된다.**
    - 내부 노드들은 단지 키만 가지고 있고 올바른 리프 노드로 연결해 주는 라우팅 기능을 한다.
- B+Tree 는 **리프 노드를 제외하고 값을 담아두지 않기 때문에 하나의 블록에 더많은 Key 들을 담아 둘 수 있다** 는 장점이 있습니다.
    - 이는 곧, 트리의 높이가 낮아짐을 나타냅니다.
    
    **B-Tree / B+Tree 차이**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/937e5cb8-e884-4958-ac79-ea61113dac23/f81e6f22-dac1-4ce3-b2e9-7a6bf88e522d/Untitled.png)
    

### 1) **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**

- B-tree에서는 자주 access 되는 노드를 루트 노드에 가깝게 배치하여 루트 노드에서 가까울 경우 브랜치 노드에도 데이터가 존재하기 때문에 B+Tree보다 빠르다.
- B+Tree는 리프 노드에만 데이터가 존재해서 이런 구현이 불가능 하다.
- B-Tree는 키의 중복이 존재하지 않는 반면에, B+Tree는 리프 노드에 모든 데이터가 존재해서 키 중복이 가능하다.

### 2) DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?

### Red-Black Tree (RBT)

RBT는 자가 균형 이진 탐색 트리로 다음과 같은 조건을 만족해야 한다

1. 모든 노드는 빨간색 혹은 검은색이다
2. 루트 노드는 검은색이다
3. 모든 리프 노드는 검은색이다
4. 빨간 노드의 자식은 검은색이다 (=빨간 노드가 연속적으로 발생할 수 없다)
5. 모든 리프 노드에서 black depth는 같다 (리프 노드에서 루트 노드까지의 경로에서 만나는 검은 노드의 개수가 같다)

### DB에서 RBT를 사용하지 않는 이유

RBT는 **이진** 탐색 트리라서 각 노드의 자식 노드가 최대 2개로 유연성이 적다.

Red-Black 특성으로 인한 조건이 세부적이라서 재구성이 흔한데, 데이터베이스에서 이 자료구조를 사용하면 부하가 올 가능성이 크다.

### DB에서 B-Tree를 사용하는 이유

1. **항상 정렬된 상태**로 특정값보다 크고 작은 부등호 연산에 문제 없다
2. 참조 포인트가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다
3. 데이터 탐색/저장/수정/삭제에도 항상 O(logN)의 시간 복잡도를 가진다

### 3)오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

1. **B-트리**
- B-트리에서는 각 노드의 키를 오름차순으로 유지합니다.
- 따라서 내림차순으로 정렬된 인덱스를 생성하려면 키의 순서를 뒤집어야 합니다.
- 이는 새로운 내림차순 인덱스를 만들 때 추가적인 작업으로, 새로운 키를 정렬된 순서에 맞게 삽입하는 과정이 필요합니다.
- 이 과정은 오름차순 인덱스를 생성하는 과정과 유사하지만, 키의 순서를 반대로 유지해야 합니다.
1. **B+트리**
    - B+트리에서도 내림차순으로 정렬된 인덱스를 생성하기 위해서는 유사한 과정이 필요합니다.
    - 각 노드의 키는 오름차순으로 유지되지만, **리프 노드에만 데이터가 저장**되므로 리프 노드에서의 키의 순서를 뒤집어야 합니다.
    - 따라서 새로운 내림차순 인덱스를 만들 때는 리프 노드에서 키의 순서를 반대로 유지하도록 새로운 키를 삽입해야 합니다.

# **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

**`Table Full Scan`**

- 테이블 전체를 순차적으로 스캔하여 조건에 맞는 데이터를 찾는 것
- 인덱스를 사용하지 않고, 테이블의 모든 행을 읽어 조건에 맞는 행을 찾는다.
- 작은 테이블에는 효과적일 수 있지만, 대용량 테이블에 대해서는 많은 자원과 시간이 소요됨
- 특히 조건에 맞는 행이 적은 경우에는 불필요 행까지 모드 읽어야 하므로 효율성 떨어짐

**`Index Scan`**

> **Loose Index Scan**
> 
> - 인덱스의 레코드를 건너 뛰면서 필요한 부분만 읽어서 가져온다.
> - 별도의 임시 테이블이 필요하지 않고, 인덱스의 유니크한 값의 수가 적을수록 성능 향상
> 
> **Tight Index Scan**
> 
> - 드라이빙 테이블(Driving) : Join문에서 먼저 액세스 되어 Access Path를 주도하는 테이블
> - 드리븐 테이블 (Driven) : 나중에 액세스되는 테이블

쿼리 조건에 따라 full index scan 또는 index range scan을 사용한다

`Index Range Scan`

- 인덱스를 수직 탐색 후 필요한 범위까지만 탐색하는 방식
- **각 리프 블록은 다음 리프 블록의 정보를 담고있어 다시 브랜치부터 읽을 필요 없이 다음 데이터를 바로 읽을 수 있다.**

### 1) **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**

- 인덱스의 효율성 :
    - 인덱스를 사용하는 것보다 Full Scan이 더 효율이 좋을 때
- 인덱스 선택 기준 :
    - 쿼리 옵티마이저가 인덱스를 선택할 때, 인덱스의 선택 기준이 쿼리의 필터링 정도에 따라 다를 수 있다.
    - 즉 쿼리에 사용된 조건이나 필터링 조건이 인덱스의 선택 여부에 영향을 줄 수 있다.

### 2) 쿼리 작성 방식에 따른 인덱스 미적용 예시가 있나요

- **WHERE 절에 인덱스 컬럼을 사용하지 않은 경우:** 쿼리 조건에 인덱스 컬럼이 포함되지 않으면 쿼리 최적화기는 인덱스 사용을 고려하지 않습니다.
- **LIKE 연산자를 사용한 경우:** LIKE 연산자는 인덱스를 사용할 수 없는 경우가 많습니다.
- **ORDER BY 절에 인덱스 컬럼을 사용하지 않은 경우:** ORDER BY 절에 지정된 컬럼이 인덱스에 포함되지 않으면 쿼리 최적화기는 Table Full Scan 방식을 선택할 수 있습니다.
