# 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

인덱스(index)는 데이터베이스에서 검색 속도를 향상시키기 위한 데이터 구조입니다. 추가 쓰기와 약간의 저장 공간을 희생하는 대신 특정 컬럼을 기준으로 테이블을 액세스할 때 빠르게 찾을 수 있습니다.

- WHERE 절이나 JOIN 조건에 자주사용되는 컬럼
- ORDER BY나 GROUP BY 절에 자주 사용되는 컬럼


## 인덱스는 어떻게 쿼리를 향상시키나요?

### WHERE

일치하는 컬럼을 찾을 때, 기존에는 전부 들여다봐서 N 시간이 걸린다면, 인덱스에서는 컬럼이 정렬되어 있으므로 logN만에 찾을 수 있습니다.

### JOIN 조건

정렬 후 조건과 일치하는 행을 찾아야 해서 MlogM + N + M이 걸릴 수 있습니다. 외래키를 기준으로 인덱스가 존재한다면 정렬이 되어 있으므로 N + M만에 찾을 수 있습니다. 

### ORDER BY

정렬해야 하므로 O(NlogN)이 걸립니다. 인덱스가 존재할 경우 이미 정렬되어 있으므로 O(N)으로 줄어듭니다.

### GROUP BY

행을 집계할 때, 일반적으로 정렬이나 해싱 사용합니다. 정렬시에는 O(NlogN)이 걸릴 수 있고, 해시 기반시 O(N)이 걸릴 수 있습니다.
GROUP By 열에 인덱스가 있는 경우 이미 정렬되어 있으므로 O(N)이 걸립니다.

### 외래키는 인덱스를 자동으로 생성하나요?

MySQL, PostegreSQL은 하위 테이블의 외래 키에 대한 인덱스를 자동으로 생성합니다.

## 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?

테이블이 수정될 때마다 insert, update, delete 작업이 일어날 때 인덱스가 추가로 업데이트됩니다. 추가 업데이트로 인해 작업이 느려질 수 있습니다.    

## ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.

ORDER BY/GROUP BY 연산시 정렬이 필요합니다. 인덱스는 이미 정렬이 되어 있으므로 빠르게 처리할 수 있습니다.   
인덱스가 존재하지 않는 경우 정렬을 하여야 하는데 대규모 데이터 세트의 경우 정렬시 시간이 오래 걸리고 리소스 집약적일 수 있습니다.

## 클러스터형 인덱스가 무엇인가요?

데이터베이스 테이블의 물리적 저장을 결정합니다. 그래서 테이블당 1개만 선택할 수 있습니다.   
클러스터형 인덱스는 실제 행을 검색하기 위해 추가적인 액세스가 필요 없기 때문에 비클러스터형 인덱스보다 빠를 수 있습니다.   
자동 증가 ID와 같이 순차적인 값을 삽입하는 경우 효율적입니다. DELETE시 조각화가 발생할 수 있습니다.(비트리)

## 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)은 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?

**MongoDB**   
전체텍스트 인덱스: 텍스트 검색 쿼리에 최적화되어 문자열 콘텐츠 내에서 효율적인 검색을 가능하게 합니다.   

**Redis**   
키-값 인덱스: 키를 기준으로 인덱스를 생성합니다. 인덱싱은 해싱 기반이므로 일반적으로 O(1)입니다.

RDB는 비트리를 기준으로 인덱스를 생성하고 관리하지만 NoSQL은 해당 데이터베이스의 성격에 따라 다른 알고리즘을 채택합니다.

## (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?

인덱스 구조가 A 기준으로 되어 있기 때문에 B 조건만 사용할 경우 인덱싱으로 올바른 값을 찾을 수 없거나 풀스캔에 비해 느릴 수 있습니다.   
인덱스를 탈 수도 있지만 일반적으로 타지 않습니다.   

# DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

두 개 이상의 테이블이 서로의 열을 결합하는 작업입니다.   
**종류**: inner, left, right, outer(left + right), cross(카테시안 곱) join

## JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.

### Nested Loop Join

첫번째 테이블의 각 행에 대해, 두번째 테이블의 전체를 검색하여 일치하는 항목을 찾습니다. 상대적으로 작은 테이블에 유리합니다.

### Hash Join

작은 테이블에 해시 테이블을 구축한 다음 큰 테이블과 해시 테이블을 사용하여 일치하는 행을 찾습니다. 이 방식은 대규모 데이터 세트에서 인덱스가 존재하지 않고, equal인 경우 효율적입니다.

### sort-merge Join

두 테이블을 조인 키를 기준으로 정렬한 다음 일치하는 행을 찾습니다. 이미 정렬되어 있거나, 범위 조건인 경우에 효율적입니다. 해시 조인의 메모리 오버헤드를 피하는 경우에도 바람직합니다.

join 방식 선택은 데이터베이스의 optimizer에 의해 선택됩니다.

## JOIN의 성능도 인덱스의 유무의 영향을 받나요?

join은 인덱스의 영향을 크게 받습니다. 인덱스를 이용하여 빠르게 처리할 수 있는 경우 인덱스를 이용하고, 없거나 안되는 경우 직접 정렬을 시도하여 결합하거나 full-scan 방식을 사용합니다.

## 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.

2중 조인은 조인 경로가 단순합니다. 그에 비해 3중 쿼리는 고려해야 할 조인 경로와 조인 조건 수가 많습니다.   
옵티마이저는 효율적으로 검색하기 위해 여러 실행 계획을 평가합니다.(테이블 크기, 사용 가능한 인덱스, 조인 조건 및 일치해야 하는 것)

### 성능 고려 사항

**잠재적인 조합의 수**   
삼중 조인은 잠재적인 조합의 수가 기하급수적으로 늘어납니다. 적절하게 인덱스 되지 않았거나 조인 조건이 충분히 선택적이지 않은 경우 실행 시간이 크게 증가할 수 있습니다.   

### 성능 완화

- 인덱스 사용: 조인할 행의 조회 시간을 줄여줍니다.
- 임시 테이블 사용: 임시 테이블을 사용하여 중간 결과를 저장합니다.
- 파티셔닝: 조인 중에 검색되는 양을 줄일 수 있습니다.

# Table Full Scan, Index Range Scan에 대해 설명해 주세요.

**Full-Scan**   
테이블의 모든 행을 검색하는 방법

**Index Range Scan**   
인덱스를 사용하여 특정 범위를 검색하는 방법

## Table Full Scan과 Index Range Scan의 성능 차이는 무엇이며, 왜 그런 차이가 발생하나요?

인덱스 방식은 디스크I/O를 줄이고, 효율적으로 필터링하기 때문입니다.

## 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

- 대부분의 데이터에 접근해야 할 때
- 작은 테이블인 경우: 인덱스를 사용하는 오버헤드가 더 클 수 있습니다.
- 낮은 카디널리티: 고유 값이 적은 경우(중복이 많음)
- 인덱스가 효과적으로 줄여주지 못하는 경우

## 쿼리 최적화 프로그램이 인덱스를 최적으로 사용하도록 보장하는 유지 관리 작업

- 통계 업데이트
- 인덱스 재구축 및 재구성

## COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?

COUNT(1), COUNT(*), COUNT(column)는 미묘하게 다릅니다. 주로 계산 대상 및 NULL 값을 처리하는 방식이 다릅니다.   

**COUNT(*)**: 행의 수를 반환합니다. null 값이 포함됩니다.   
**COUNT(1)**: 행의 수를 반환합니다. 열의 형태나 값을 고려하지 않습니다.
**COUNT(column)**: 해당 column이 null이 아닌 행의 수를 반환합니다.

### COUNT(*)와 COUNT(1) 성능

COUNT(1)이 열 값을 고려하지 않기 때문에 효율적일 수 있습니다. 하지만 최신 RDBMS는 COUNT(*)가 행을 고려할 필요 없다는 것을 알만큼 똑똑합니다. 그래서 둘 사이 성능에 큰 차이가 없습니다.   
COUNT(*)가 테이블의 행 수를 계산하는 것에 명시적이므로 선호합니다. 보기엔 없지만 count()도 좋을 것 같습니다.

# B-Tree와 B+Tree를 비교해주세요

## B Tree

B tree는 균형을 유지하는 트리 구조로, 모든 리프 노드가 같은 레벨에 위치합니다. 각 노드는 일정 범위의 자식을 가질 수 있으며(이진 트리의 일반적인 형태), 데이터는 키-값 쌍으로 저장됩니다.   
각 노드는 최대 M-1개의 키를 가질 수 있으며, M은 트리의 차수입니다.   
노드 내의 데이터는 정렬되어 있으며, 자식 노드들은 부모 노드들 사이의 값을 가집니다.   
검색, 삽입, 삭제 연산의 시간 복잡도는 O(logN)입니다.

## B+Tree

B Tree의 변형된 형태로, 모든 데이터는 리프 노드에만 저장됩니다. 내부 노드는 리프 노드로의 가이드 역할만 수행합니다.   
리프 노드는 모든 데이터를 포함하며, 이 노드들은 서로 연결리스트로 연결되어 순차 접근을 지원합니다.   
내부 노드는 자식 노드의 최소값을 포인터로 가지며 데이터는 리프 노드에만 존재합니다.   
B Tree에 비해 중복이 많아 더 많은 레벨을 가질 수 있지만, 디스크 입출력 효율이 높습니다.

### B+Tree가 디스크 입출력 효율이 높은 이유

B+Tree는 모든 데이터가 리프 노드에 순차적으로 저장되기 때문에 범위 탐색이나 순차 접근에 효율성이 향상되며 디스크 IO를 최소화합니다.   
데이터가 리프 노드에만 저장되기 때문에 내부 노드는 더 많은 수의 자식 노드를 가리키는 포인터를 저장할 수 있습니다.   

### B Tree에 비해 B+Tree가 가지는 단점

- 포인터를 보관하고 있기 때문에 저장 공간을 더 많이 사용한다는 단점이 존재합니다.
- B+Tree는 순차 접근과 범위 검색에 최적화되어 있지만, 빈번한 랜덤 액세스가 요구될 경우 B Tree에 비해 비효율적일 수 있습니다.(매번 리프 노드까지 가야하므로, 트리의 깊이가 깊어질수록 더 많은 디스크 접근 필요)

## DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?

디스크 IO 때문입니다. 디스크에서 정보를 가져올 때 이진 단위된 일정 데이터를 가져옵니다.   
RBT는 일정량의 데이터를 가져오더라도 1개의 데이터만 가져오기 때문에 많은 디스크IO 작업이 발생합니다. 이에 반해 비트리 구조는 m-1개의 데이터를 한 번에 가져올 수 있어 효율적입니다.

## 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

인덱스를 읽는 순서를 정순으로 읽느냐 역순으로 읽느냐에 차이라서 차이가 없을 것 같지만, 내부적으로 Forward index scan에 유리한 구조로 설계되어 있다. 그래서 차이가 발생합니다.   
기본적으로 `Ascending` 되어 있으므로 내림차순 읽기가 빈번할 경우 `Descending` 로 인덱스를 구성한다면 약간의 성능 향상을 얻을 수 있습니다.