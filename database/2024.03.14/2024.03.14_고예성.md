# 3/14 데이터베이스

- **인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**
    
    인덱는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다.
    
    특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 
    
    별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
    
    인덱스를 책에서의 목차라고 생각하면 이해하기 쉽다.
    
    책에서 원하는 내용을 찾을 때, 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있듯이
    
    테이블에서 원하는 데치터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있다.
    
    그러므로 ‘데이터=책의 내용’, ‘인덱스=책의 목차’, ‘물리적 주소=책의 페이지 번호’라고 생각하면 된다.
    
    인덱스는 여러 자료구조를 이용해서 구현할 수 있는데, 대표적인 자료구조로 해시 테이블과 B+Tree가 있다.
    
    ### 해시 테이블(Hash Table)
    
    해시 테이블은 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장하는 자료구조이다.
    
    하지만 해시 테이블은 실제로 인덱스에서 잘 사용하지 않는다.
    
    그 이유는 해시테이블은 등호(=) 연산에 최적화 되어있기 떄문이다. 
    
    데이터베이스에선 부등호(< , >) 연산이 자주 사용되는데,
    
    해시 테이블 내의 데이터들은 정렬되어 있지 않으므로 
    
    특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.
    

    
    ### B+Tree
    
    B+Tree는 대부분의 DBMS 그리고 오라클에서 특히 중심적으로 사용하고 있는 가장 보편적인 인덱스이다.
    
    구조는 Root Node(기준) / Branch Node(중간) / Leaf Node(말단) 으로 구성되며 계층적 구조를 가지고 있다.
    
    
    1. Node는 데이터가 존재하는 공간이다.
    2. Leaf Node만 인덱스와 함께 데이터를 가지고 있고, 나머지 Root Node와 Branch Node는 데이터를 위한 인덱스(Key)만 갖는다.
    3. Leaf Node에만 데이터를 저장하고 Leaf Node들끼리 LinkedList로 연결되어 있어 선형시간이 소모되어 시간 효율이 올라간다.
    4. Root Node에서 경로를 확인 후, 그에 알맞는 Node들로 이동하여 최종적으로 원하는 데이터가 있는 Leaf Node에 도달한다.
    
    - **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
        1. **인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지시켜야 한다는 점**
            
            인덱스가 적용된 컬럼에 정렬을 변경시키는 INSERT, UPDATE, DELETE 명령어가 수행된다면
            
            계속 정렬을 해줘야해서 그에 따른 부하가 발생한다. 
            
            이런 부하를 최소화하기 위해 인덱스는 데이터가 삭제될 때 인덱스 값을 삭제하는 것이 아니라
            
            ‘인덱스 데이터를 사용하지 않는다’로 대신 작업한다.
            
            - INSERT : 새로운 데이터에 대한 인덱스를 추가
            - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
            - UPDATE : 기존의 인덱스를 사용하지 않음 처리하고 갱신된 데이터에 대해 인덱스 추가
            
        2. **무조건 인덱스 스캔이 좋은 것은 아니다**
            
            검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋지만, 
            
            무조건 인덱스가 검색에 좋은 것은 아니다.
            
            예를 들어, 1개의 데이터가 있는 테이블과 100만개의 데이터가 들어있는 테이블이 있다고 하자.
            
            100만개의 데이터가 들어있는 테이블이라면 풀 스캔보다는 인덱스 스캔이 유리하겠지만,
            
            1개의 데이터가 들어있는 테이블은 인덱스 스캔보다 풀스캔이 더 빠르다.
            
        
        1. **속도 향상을 위해 인덱스를 많이 만드는 것이 좋지 않다.**
            
            인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다.
            
            때문에 너무 많이 인덱스를 생성하면 하나의 쿼리문을 빠르게 만들 수 있지만,
            
            대신에 전체적인 데이터베이스의 성능 부하를 추래한다.
            
            때문에 무조건적인 인덱스 생성보다 SQL문을 효율적으로 짜고, 
            
            인덱스 생성은 마지막 수단으로 사용해야 한다. 
            
        
    - **그렇다면 인덱스에서 사용하지 않겠다고(인덱스의 삭제 동작) 선택한 값은 위 정책을 그대로 따라가나요?**
        
        인덱스 업데이트 방식을 사용할 경우에도 인덱스 트리의 정책을 그대로 따라가게 됩니다. 삭제처리한 값에 대해 노드는 실제 데이터를 가리키는 포인터를 제거하거나 삭제 마커를 설정하여 더 이상 해당 값을 참조하지 않도록 표시합니다. 
        
        검색할 때 인덱스 트리에서는 유효한 인덱스 노드를 따라 이동하여 원하는 값을 찾게 됩니다. 만약 해당 값이 삭제된 것으로 처리되면 해당 값을 무시하고 유효한 값을 찾아갑니다.
        
        따라서 인덱스 업데이트 방식을 사용할 경우에도 인덱스 트리의 구성에 포함되어 정책을 따라가게 됩니다.
        
    - **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
        
        **GROUP BY의 인덱스**
        
        - GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다.
        - 인덱스를 구성하는 칼럼 중에서 뒷쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
        - GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 사용하지 못한다.
        
        **ORDER BY의 인덱스**
        
        - ORDER BY 절의 인덱스 사용여부는 GROUP BY의 조건과 흡사하다. 하지만 ORDER BY는 조건이 하나 더 있는데, 정렬되는 각 칼럼의 오름차순(ASC) 및 내림차순(DESC) 옵션이 인덱스와 같거나 또는 정반대인 경우에만 사용할 수 있다.
            
            즉, 인덱스 칼럼의 순서가 오름차순 혹은 내림차순으로 ORDER BY에 들어가야 한다.
            
            **WHERE 조건과 ORDER BY(혹은 GROUP BY)**
            
            ### WHERE절과 ORDER BY 절이 동시에 같은 인덱스 이용
            
            - 아래 두 조건보다 훨씬 빠르다
            - 만약 다른 인덱스를 각각 쓴다면, 아래 두 방법 중 하나로 처리될 것이다 (실행계획 확인 필요)
            
            ### WHERE 절만 인덱스를 사용
            
            - ORDER BY 절은 인덱스를 쓸 수 없고 WHERE 절은 인덱스를 쓸 수 있을 때
            - 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정(FileSort)을 거쳐 정렬을 수행한다. 주로 이 방법은 WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을때 효과적이다
            
            ### ORDER BY 절만 인덱스를 사용
            
            - ORDER BY 절은 인덱스를 쓸 수 있지만, WHERE 절은 인덱스를 못 쓸 때
            - ORDER BY 절의 순서대로 인덱스를 읽으며, 레코드 한 건씩을 WHERE 절의 조건에 일치하는지 비교해 일치하지 않을때 버리는 형태로 처리. 아주 많은 레코드를 조회해서 정렬해야 할 때는 이런 형태로 튜닝하기도 한다.
            
            ### GROUP BY + ORDER BY
            
            - GROUP BY 절에 명시된 칼럼과 ORDER BY에 명시된 칼럼이 순서와 내용이 모두 같아야 한다. GROUP BY와 ORDER BY가 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘다 인덱스를 사용하지 못한다.
            - MySQL의 GROUP BY는 ORDER BY 칼럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이므로 GROUP BY와 ORDER BY 칼럼이 내용과 순서가 같은 쿼리에서는 ORDER BY 절을 생략해도 같은 결과를 얻게 된다.
        
    - **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
        
        일반적으로 DBMS에서 PK는 자동으로 Index가 적용된다.
        
        PK는 개념적인 값이다. PK는 여러 Tuple 중 유일한 Tuple임을 보장한다.
        
        실제 값이 존재하지만 PK라고 따로 물리적으로 저장되지 않기 때문이다.
        
        반면 Index는 Tuple들의 유일성을 보장하지 않는다.
        
        Index는 단지 테이블에서 Tuple을 보다 빨리 찾기 위해 사용된다.
        
        Index를 걸면 Index를 거는 칼럼 기준으로 새로운 자료구조를 생성하여 별도의 디스크 공간에 저장한다.
        
    
    - **그렇다면 외래키는요?**
        
        DB by DB이다. MySQL과 같은 특정 DB는 FK를 걸면 
        
        FK에 index를 걸어주기도 한다.
        
        (stackoverflow의 [몇](https://stackoverflow.com/questions/304317/does-mysql-index-foreign-key-columns-automatically)[몇](https://stackoverflow.com/questions/304317/does-mysql-index-foreign-key-columns-automaticallyhttps://stackoverflow.com/questions/6230588/foreign-keys-must-be-index-in-mysql) 대답에서는 InnoDB를 사용하는 경우에만 index가 생성된다고 한다)
        
        [https://ivvve.github.io/2020/07/08/server/rdb/is-fk-indexed/](https://ivvve.github.io/2020/07/08/server/rdb/is-fk-indexed/)
        
    - **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
        
        일반적으로 인덱스는 데이터의 물리적 저장에는 직접적인 영향을 미치지 않습니다. 인덱스는 데이터에 대한 논리적인 순서를 정의하고, 데이터에 대한 빠른 검색을 위해 사용됩니다. 인덱스는 데이터베이스 시스템이 데이터를 조직화하고 액세스하는 방법을 결정하는 데 사용됩니다.
        
        데이터는 디스크 상에 물리적으로 저장될 때, 보통 테이블에 삽입된 순서대로 저장되지 않습니다. 대신에, 데이터베이스 시스템은 효율적인 데이터 접근을 위해 데이터를 블록 단위로 관리하며, 이러한 블록들은 디스크에 연속적으로 저장될 수 있습니다. 그러나 데이터베이스 시스템은 데이터베이스 내부적으로 물리적인 저장 구조를 최적화하기 위해 여러 가지 기술을 사용할 수 있습니다.
        
        예를 들어, 클러스터드 인덱스를 사용하는 경우, 인덱스의 순서와 실제 데이터의 물리적인 저장 순서가 유사하게 유지될 수 있습니다. 이는 검색 시에 디스크 I/O를 줄이고 데이터에 대한 접근 속도를 향상시킬 수 있습니다. 그러나 이는 일반적인 상황이 아닙니다. 클러스터드 인덱스를 사용하지 않는 경우, 인덱스의 순서와 데이터의 물리적 저장 순서는 일치하지 않을 수 있습니다.
        
        결론적으로, 인덱스는 데이터의 논리적인 구조를 정의하고 검색을 용이하게 합니다. 데이터의 물리적인 저장은 데이터베이스 시스템이 관리하며, 데이터에 대한 접근 속도 및 성능을 최적화하기 위해 여러 가지 기술이 사용될 수 있습니다.
        
        [https://luv-n-interest.tistory.com/621](https://luv-n-interest.tistory.com/621)
        
    - **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
        
        NoSQL 데이터베이스도 일반적으로 인덱스를 가지고 있습니다. 그러나 NoSQL 데이터베이스에서의 인덱스는 전통적인 RDB의 인덱스와 다를 수 있습니다. 여기에는 주로 다음과 같은 차이점이 있습니다:
        
        1. **구조적인 유연성**: NoSQL 데이터베이스는 스키마가 유연하고 동적입니다. 이로 인해 NoSQL 데이터베이스의 인덱스는 RDB에서처럼 엄격한 스키마에 의존하지 않습니다. 대신, NoSQL 데이터베이스는 일반적으로 자유로운 형태의 데이터 구조를 다루기 때문에, 인덱스 역시 이러한 유연성을 반영하도록 설계됩니다.
        2. **다양한 유형의 인덱스**: RDB에서는 주로 B+트리와 같은 자료 구조를 사용하여 인덱스를 구현합니다. 그러나 NoSQL 데이터베이스에서는 다양한 유형의 인덱스가 사용될 수 있습니다. 예를 들어, MongoDB에서는 기본적으로 B-tree 인덱스를 사용하지만, Geospatial 인덱스, Text 인덱스 등의 특수한 유형의 인덱스도 제공합니다.
        3. **분산 환경 고려**: 많은 NoSQL 데이터베이스는 분산 환경에서 운영되며, 이는 데이터의 쉬운 확장성과 가용성을 제공합니다. 따라서 NoSQL 데이터베이스의 인덱스는 이러한 분산 환경에서 효과적으로 작동할 수 있도록 설계되어야 합니다.
        4. **비관계형 데이터 처리**: NoSQL 데이터베이스는 주로 비관계형 데이터를 다룹니다. 이는 데이터 구조가 테이블, 열 및 행으로 구성되지 않는다는 것을 의미합니다.
        
        MongoDB 고정된 스키마는 없지만, 원하는 데이터 필드를 인덱스로 지정하여 검색 결과를 빠르게 하는 것이 가능합니다.
        
        - index는 한 쿼리에 한 index만 유효합니다. 따라서 두 개의 index 가 필요하다면 복합 index를 사용합니다.
        - index는 어떤 데이터가 도큐먼트에 추가되거나 수정될 때( write 작업 ) 그 컬렉션에 생성되어 있는 index도 새로운 도큐먼트를 포함시켜 수정됩니다. 이로 인하여 index 추가 시 wirte 작업은 느려질 수 있습니다. 따라서 index는 read 작업 위주의 애플리케션에서 유용하고 읽기보다 쓰기 작업이 많으면 index를 추가하는 것은 고려해야 합니다.
        - 인덱스는 일반 필드 뿐만 아니라,
            
            객체 값을 가지는필드의 내부 속성에도지정할 수 있습니다. 
            
            예를 들어{ name: { first: 'Zero', last: 'Cho' } } 가 있을 경우createIndex({ 'name.last': 1 }); 이렇게 인덱스 지정이 가능합니다.
            
            참고로_id 필드는 자동으로 인덱스 설정이 되어 있습니다.
            
            웬만한 경우면 _id를 사용해서 조회하는 게 좋습니다.
            
        - MongoDB의 기본 인덱스 구조는 B-Tree 인덱스입니다.
        
        [https://rastalion.me/mongodb-index-1-architecture/](https://rastalion.me/mongodb-index-1-architecture/)
        
        [https://ryu-e.tistory.com/1](https://ryu-e.tistory.com/1)
        
        [https://inpa.tistory.com/entry/MONGO-📚-Index-정리](https://inpa.tistory.com/entry/MONGO-%F0%9F%93%9A-Index-%EC%A0%95%EB%A6%AC)
        
    - **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**
        
        선두 칼럼이 조건절에 포함되어 있지 않다보니 인덱스 대부분을 확인해야 하는 상황이 되고 이를 토대로 테이블에 접근까지 해야하는 상황(SELECT * 때문)이기 때문에 옵티마이저가 테이블 풀스캔을 수행한 것으로 이해할 수 있다. 
        
        [https://one-armed-boy.tistory.com/47](https://one-armed-boy.tistory.com/47)
        

- **DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**
    
    조인이란 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것이다. 따라서 조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.
    
    관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리는 관계를 갖게 된다. 이와 같은 특징으로 관계형 데이터베이스는 저장 광간의 효율성과 확장성이 향상되게 된다. 다른 한편으로는 서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.
    
    ### 내부조인(INNER JOIN)
    
    - 여러 애플리케이션에서 사용되는 가장 흔한 결합 방식이며 기본 조인 형식으로 간주된다.
    - 내부 조인은 조인 구문에 기반한 2개의 테이블(A, B)의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성한다.
    - 명시적 조인 표현(explicit)과 암시적 조인 표현(implicit) 2개의 다른 조인식 구문이 있다.
    
    명시적 조인 표현
    
    > 테이블끼리 조인 하는 것을 지정하기 위해 JOIN 키워드를 사용하며 그리고 나서 다음의 예제와 같이 ON 키워드를 조인에 대한 구문을 지정하는데 사용한다.
    > 
    
    ```sql
    SELECT * FROM employee INNER JOIN department ON employee.DepartmentID = department.DepartmentID;
    ```
    
    암시적 조인 표현
    
    > SELECT 구문의 FROM 절에서 그것들을 분리하는 컴마를 사용해서 단순히 조인을 위한 여러 테이블을 나열하기만 한다.
    > 
    > 
    > ```sql
    > SELECT * FROM employee, department WHERE employee.DepartmentID = department.DepartmentID;
    > ```
    > 
    
    ### 동등 조인(EQUAL JOIN)
    
    - 비교자 기반의 조인이며, 조인 구문에서 동등비교만을 사용한다.
    - 다른 비교 연산자(<와 같은)를 사용하는 것은 동증 조인으로서의 조인의 자격을 박탈하는 것이다.
    
    ### 자연 조인(NATURAL JOIN)
    
    - 동등 조인의 한 유형으로 조인 구문이 조인된 테이블에서 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교함으로써 암시적으로 일어나는 구문이다.
    - 결과적으로 나온 조인된 테이블은 동일한 이름을 가진 컬럼의 각 쌍에 대한 단 하나의 컬럼만 포함하고 있다.
    
    ```sql
    SELECT * FROM employee NATURAL JOIN department;
    ```
    
    ### 교차 조인(CROSS JOIN)
    
    - 조인되는 두 테이블에서 곱집합을 반환한다.
    - 즉, 두 번째 테이블로부터 각 행과 첫 번째 테이블에서 각 행이 한번씩 결합된 열을 만들 것이다.
    - 예를 들어 m행을 가진 테이블과 n행을 가진 테이블이 교차 조인되면 m*n 개의 행을 생성한다.
    
    명시적 조인 표현
    
    ```sql
    SELECT * FROM employee CROSS JOIN department;
    ```
    
    암시적 조인 표현
    
    ```sql
    SELECT * FROM employee, department;
    ```
    
    ### 외부 조인(OUTER JOIN)
    
    - 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용하여 효과적으로 결과 집합을 생성할 수 있다.
    
    ### 왼쪽 외부 조인(LEFT OUTER JOIN)
    
    - 우측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다.
    - 즉, 좌측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
    
    ```sql
    SELECT * FROM employee LEFT OUTER JOIN department ON employee.DepartmentID = department.DepartmentID;
    ```
    
    ### 오른쪽 외부 조인(RIGHT OUTER JOIN)
    
    - 좌측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다.
    - 즉, 우측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
    
    ```sql
    SELECT * FROM employee RIGHT OUTER JOIN department ON employee.DepartmentID = department.DepartmentID
    ```
    
    ### 완전 외부 조인(FULL OUTER JOIN)
    
    - 양쪽 테이블 모두 OUTER JOIN이 필요할 때 사용한다.
    
    ```sql
    SELECT * FROM employee FULL OUTER JOIN department ON employee.DepartmentID = department.DepartmentID;
    ```
    
    - **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
        
        SQL에서 조인 연산을 수행할 때 내부적으로 선택되는 알고리즘에는 *Nested Loops Join, Hash Join, Sort Merge Join* 등이 있다. 이 중 어느 알고리즘을 선택할지는 **데이터의 크기, 결합키(Key), 인덱스(Index)**에 따라 옵티마이저가 결정한다.
        
        ### Nested Loops Join
        
        Nested Loops Join은 중첩 반복을 사용하는 알고리즘이다.
        
        1. 테이블 A와 테이블 B가 어떤 Key를 기준으로 결합을 진행한다
        2. 테이블 A (Driving Table)의 첫번째 행부터 출발해 테이블 B (Driven Table)의 모든 행을 스캔해서 결합 조건이 맞으면 값을 리턴한다
        3. 테이블 A의 첫 행의 스캔이 끝나면 두번째 행이 테이블 B의 모든 행을 스캔한다
        4. 2~3번의 과정을 반복해서 테이블 A의 마지막 행이 테이블 B의 모든 행을 스캔하면 결합이 완료된다.
        
        시간복잡도가 O(M * N)으로 결정됨
        
        각 테이블의 결합 대상 레코드 수를 R(A), R(B)라 하면 접근되는 레코드 수는 R(A)*R(B)다.* 
        
        *성능을 높이려면 R(A)*R(B)의 값을 낮춰야 하는데, 
        
        이를 위해서는 **Driving Table이 작고, Driven Table의 결합키 필드에 인덱스가 존재해야 한다.**
        
        Driven Table의 결합키에 인덱스가 존재하면 Driving Table에서 Driven Table을 스캔할 때 
        
        모든 행에 대해 스캔할 필요가 없어진다.
        
        어느 테이블을 Driving Table로 선정할지도 옵티마이저의 몫이다. 
        
        Inner Join에는 실행비용을 최소화하는 방향으로 지정하지만, 
        
        Outer Join은 어느 테이블을 먼저 읽는지에 따라 결과값이 달라지기 때문에 
        
        옵티마이저가 선정하지 않고, 쿼리의 입력을 따른다.
        
        ### Sort Merge Join (정렬 병합 조인)
        
        Sort Merge Join은 조인 컬럼을 기준으로 데이터를 정렬해서 조인을 수행한다.
        
        1. Driving Table에서 주어진 조건을 만족하는 행을 찾는다
        2. Driving Table의 조인 키를 기준으로 정렬 작업을 수행한다
        3. 1~2번의 작업을 Driving Table의 조건을 만족하는 모든 행에 대해 반복 수행한다
        4. Driven Table에서 주어진 조건을 만족하는 행을 찾는다
        5. Driven Table의 조인 키를 기준으로 정렬 작업을 수행한다
        6. 4~5번의 작업을 Driven Table의 조건을 만족하는 모든 행에 대해 반복 수행한다
        7. 정렬된 결과를 이용해 조인을 수행하고, 성공하면 추출버퍼에 넣는다
        
        - 정렬할 데이터가 많으면 임시영역(디스크)를 사용하기 때문에 성능이 저하된다
        - 인덱스를 사용하지 않아서 인덱스가 존재하지 않을 경우에도 사용이 가능하다
        - 비동등 조인에 대해서도 조인 작업이 가능하다
        - 스캔 방식을 사용한다
        
        ### Hash Join
        
        Hash Join은 해시 함수를 이용해서 데이터를 조인한다. 조인을 수행할 테이블의 조인 컬럼을 기준으로 해시 함수를 수행해서 동일한 해시 값을 갖는 것들 중 실제 값이 같은지를 비교하며 조인을 수행한다. 이렇게 Nested Loops Join의 랜덤 액세스 문제와 Sort Merge Join의 정렬 작업 부담을 해결한다.
        
        1. Driving Table에서 주어진 조건을 만족하는 행을 찾는다.
        2. Driving Table의 조인 키를 기준으로 해시 함수를 적용하여 해시 테이블을 생성한다. 
            
            이 때 조인 컬럼과 SELECT 절에서 필요로 하는 컬럼도 함께 저장된다.
            
        3. 1~2번 작업을 Driving Table의 조건을 만족하는 모든 행에 대해 반복 수행한다
        4. Driven Table에서 주어진 조건을 만족하는 행을 찾는다.
        5. Driven Table의 조인키를 기준으로 해시 함수를 적용하여 해당 버킷을 찾는다
        6. 조인에 성공하면 추출버퍼에 넣는다. 4~5번 작업을 Driven Table의 조건을 만족하는 모든 행에 대해 반복 수행한다.
        
        장점:
        
        - 조인 컬럼의 인덱스를 사용하지 않는다
            
            > 조인 컬럼의 인덱스가 존재하지 않아도 사용할 수 있다
            
        
        단점:
        
        - 동등 조인에서만 사용할 수 있다
        - 해시 함수를 적용한 값은 기존값을 알 수 없다
        - 해시 테이블을 메모리에 생성해야 해서 크기가 크면 임시 영역에 저장해야 한다. (결과 행의 수가 적은 테이블을 Driving Table)로 사용하는 것이 좋다
        
    - 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
        1. **실행 계획 확인**: 대부분의 RDBMS는 쿼리 실행 전에 실행 계획을 생성합니다. 이 실행 계획에는 각 테이블에 대한 접근 방법 및 조인 방법 등이 포함됩니다. 실행 계획을 확인하면 DBMS가 어떤 조인 알고리즘을 선택했는지 알 수 있습니다. 대부분의 DBMS에서는 **`EXPLAIN`** 또는 **`EXPLAIN PLAN`**과 같은 명령을 사용하여 실행 계획을 확인할 수 있습니다.
        2. **시스템 통계 및 구성 옵션 확인**: DBMS는 일반적으로 쿼리 실행에 대한 통계 정보를 수집하고 이를 기반으로 최적화된 실행 계획을 선택합니다. 이러한 통계 정보 및 DBMS의 구성 옵션은 어떤 조인 알고리즘이 선택되는지에 영향을 줄 수 있습니다. 따라서 DBMS의 통계 정보 및 구성 옵션을 확인하여 조인 알고리즘을 추론할 수 있습니다.
        3. **쿼리 실행 시간 및 성능 프로파일링**: 다양한 조인 알고리즘은 서로 다른 성능 특성을 가집니다. 따라서 쿼리 실행 시간을 측정하고 성능 프로파일링을 수행하여 어떤 조인 알고리즘이 사용되었는지를 추론할 수 있습니다. 예를 들어, Nested Loops Join은 작은 테이블에 대해서는 효과적일 수 있지만 큰 테이블에 대해서는 비효율적일 수 있습니다.
        
        이러한 방법을 사용하여 어떤 조인 알고리즘이 사용되었는지를 확인할 수 있지만, 정확한 알고리즘 선택은 DBMS의 내부 최적화 엔진에 의해 결정되므로 완벽하게 예측하기는 어렵습니다
        
    - 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
        1. **Nested Loops Join**:
            - Nested Loops Join은 가장 간단한 JOIN 알고리즘 중 하나로, 하나의 테이블을 기준으로 다른 테이블을 순회하면서 매칭되는 행을 찾는 방식입니다.
            - 인덱스가 있는 경우, 내부 루프에서 더 빠르게 조인 대상을 찾을 수 있습니다. 조인 대상 열에 인덱스가 있는 경우 특히 성능이 향상될 수 있습니다.
        2. **Sort Merge Join**:
            - Sort Merge Join은 두 테이블을 각각 정렬한 다음에 정렬된 상태에서 조인하는 방식입니다.
            - 인덱스가 있는 경우, 정렬 작업이 더 빠르게 수행될 수 있습니다. 특히 조인 조건에 사용되는 열이 인덱싱되어 있는 경우 성능이 향상될 수 있습니다.
        3. **Hash Join**:
            - Hash Join은 해시 함수를 사용하여 두 테이블을 해시 키로 매핑한 다음, 매칭되는 해시 키를 가진 행을 조인하는 방식입니다.
            - 인덱스가 있는 경우, 해시 함수의 작동이 더 빠르게 수행될 수 있습니다. 특히 조인 조건에 사용되는 열이 해시 함수의 입력으로 사용되는 경우 성능이 향상될 수 있습니다.
                
                Hash Join은 인덱스 없이도 사용할 수 있는 JOIN 알고리즘 중 하나입니다. Hash Join은 일반적으로 두 개의 테이블을 메모리나 디스크에서 해시 테이블로 로드한 다음, 각 테이블의 조인 키를 해시하여 매핑한 다음 매칭되는 행을 결합합니다.
                
                Hash Join은 인덱스를 사용하지 않고도 수행될 수 있기 때문에, 인덱스의 유무가 Hash Join의 성능에 직접적인 영향을 미치지는 않습니다. 그러나 Hash Join의 성능은 주로 메모리 및 디스크 I/O의 사용, 해시 함수의 성능, 데이터의 분산 정도 등에 영향을 받습니다. 인덱스가 있는 경우에도 Hash Join은 여전히 사용될 수 있으며, 성능은 데이터의 특성과 함께 고려되어야 합니다.
                
        
    - 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요
        
        3중 이상의 조인에서는 조인 알고리즘이 복잡해지며, 일반적으로 다음과 같은 두 가지 방법 중 하나를 사용하여 수행됩니다.
        
        1. **Nested Loops Join의 중첩**: 가장 간단한 방법은 Nested Loops Join을 중첩하여 사용하는 것입니다. 즉, 먼저 두 테이블 간의 조인을 수행한 후, 그 결과를 다른 테이블과 조인하는 과정을 반복합니다. 이러한 방식은 각 단계에서 하나의 테이블만 메모리에 로드하면 되므로 메모리 사용량이 낮을 수 있습니다. 그러나 이는 중첩된 루프의 수가 많아질수록 성능이 저하될 수 있습니다.
        2. **Hash Join 또는 Sort Merge Join의 조합**: 또 다른 방법은 Hash Join 또는 Sort Merge Join을 조합하여 사용하는 것입니다. 이 경우 먼저 두 개의 테이블 간의 조인을 수행한 후, 그 결과를 다른 테이블과 조인합니다. 이 방법은 각 단계에서 중간 결과를 메모리나 디스크에 저장해야 하므로 더 많은 메모리를 필요로 할 수 있습니다. 그러나 이 방법은 중첩된 루프의 수에 관계없이 일정한 성능을 유지할 수 있습니다.
        
        이러한 방법들은 다중 조인의 성능에 영향을 미칩니다. 일반적으로 Nested Loops Join의 중첩은 많은 수의 테이블 또는 큰 테이블의 조인에는 비효율적일 수 있습니다. 그러나 Hash Join 또는 Sort Merge Join의 조합은 일반적으로 성능이 좋으며, 특히 중간 결과가 메모리에 맞는 경우에 더욱 효율적입니다. 하지만 이러한 방법들은 각각의 데이터의 특성과 시스템 환경에 따라 성능이 달라질 수 있습니다.
        

- **Table Full Scan, Index Range Scan에 대해 설명해 주세요.**
    
    ### Index Scan
    
    ### Loose Index Scan
    
    루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져온다. 이 방식에는 별도의 임시 테이블이 필요하지 않고, 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다
    
    ### Tight Index Scan
    
    > 드라이빙 테이블 (DRIVING TABLE, OUTER TABLE): JOIN문에서 먼저 액세스되어 ACCESS PATH를 주도하는 테이블
    > 
    > 
    > **드리븐 테이블 (DRIVEN TABLE, INNER TABLE)**: 나중에 액세스되는 테이블
    > 
    
    쿼리 조건에 따라 full index scan 또는 index range scan을 사용한다
    
    ### Table Full Scan과 Index Range Scan
    
    ### Full Scan
    
    풀스캔은 인덱스를 타지 않고, 스토리지 엔진이 처음부터 끝까지 전부 읽어서 요청된 작업을 처리하는 방법이다. MySQL은 (1) 테이블의 레코드 수가 너무 적어서 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 빠를 것이라 예상하거나 (2) WHERE/ON절에 인덱스를 이용할 수 있는 적절한 조건이 없거나 (3) 인덱스 레인지 스캔이 적용될 수 있어도 조건에 일치하는 레코드 건수가 너무 많을 것이라 예상되면 풀 테이블 스캔 방식을 채택한다
    
    ### Index Range Scan
    
    인덱스를 수직 탐색 후 필요한 범위까지만 탐색하는 방식이다. 각 리프 블록은 다음 리프블록의 정보를 담고 있어 다시 브랜치부터 읽을 필요 없이 다음 데이터를 바로 읽을 수 있다.
    
    - **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
        
        링크참조 : [https://hjjungdev.tistory.com/115](https://hjjungdev.tistory.com/115)
        
    - **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?**
        
        COUNT 함수는 데이터베이스에서 특정 조건을 만족하는 행의 수를 세는 데 사용됩니다. 일반적으로 다음과 같은 방식으로 동작합니다:
        
        1. **전체 스캔**: 가장 간단한 방법은 데이터베이스가 전체 테이블을 스캔하면서 조건을 만족하는 행의 수를 세는 것입니다. 이 방법은 작은 테이블이나 조건이 없는 경우에는 비교적 빠르게 동작할 수 있지만, 대량의 데이터를 처리하는 경우 성능이 저하될 수 있습니다.
        2. **인덱스 스캔**: 조건에 해당하는 인덱스가 있는 경우, COUNT 함수는 해당 인덱스를 사용하여 효율적으로 행의 수를 세는 것이 가능합니다. 인덱스는 조건을 만족하는 행을 빠르게 찾을 수 있으므로, 인덱스 스캔을 통해 COUNT 작업을 수행하는 것이 더 효율적일 수 있습니다.
        3. **통계 정보 사용**: 일부 데이터베이스는 통계 정보를 사용하여 COUNT 작업을 최적화할 수 있습니다. 데이터베이스는 테이블의 크기, 인덱스의 카디널리티, 행의 분포 등의 정보를 기반으로 최적의 실행 계획을 선택합니다. 이를 통해 COUNT 작업을 더 효율적으로 수행할 수 있습니다.
        4. **캐시 사용**: 이전에 동일한 COUNT 작업이 실행된 경우, 일부 데이터베이스는 결과를 캐시하여 다시 계산하지 않고 이전에 계산된 결과를 사용할 수 있습니다. 이를 통해 반복적인 COUNT 작업의 성능을 향상시킬 수 있습니다.
        
        **COUNT(1)과 COUNT(*) 차이가 없다.**
        
        COUNT(*)는 NULL 값을 포함하는지 여부에 관계없이 검색된 행 수의 카운트를 반환
        
        COUNT(1), COUNT(0), COUNT(-2312312313) 모두 똑같이 동작함
        
        COUNT(칼럼명) 은 NULL값은 제외하고 나온다.
        
        **COUNT(*)**은 NULL값을 비교하지 않기 때문에 **속도가 빠르다** 
        
        -> 데이터를 읽지 않고 레코드 수만 불러오기 때문
        
        **COUNT(칼럼명)은** 실제 데이터를 들여다보기 때문에 **속도가 느리다**
        
        + 인덱스를 걸어도 속도는 마찬가지