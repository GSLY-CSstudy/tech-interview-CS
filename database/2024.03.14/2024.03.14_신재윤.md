
# GSLY 면접스터디

**2주차 질문 목록**

- **GSLY 면접스터디**
  - [5번 질의](#5번-질의)
  - [9번 질의](#9번-질의)
  - [15번 질의](#15번-질의)
  - [참고 자료](#참고-자료)

<hr>

## 5번 질의

<details><summary>5-1. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요. (출처 : vsfe)</summary>

<br>

- <ins><strong>인덱스 (Index)</strong></ins> : 추가적인 쓰기 작업과 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

    - 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장

    - 인덱스를 위해 DB 10% 내외의 추가 공간이 필요하다. 따라서, 데이터가 많으면 인덱스 생성에 많은 시간이 소요될 수 있음

    - 인덱스를 사용하지 않은 컬럼을 조회하려면 전체를 비교하며 탐색(Full Scan)해야 해서 처리 속도가 떨어짐

    - 조희 성능은 좋으나, 오히려 삽입/수정/삭제 등의 경우 오히려 성능이 저하됨

    - 대표적으로 (Key,Value)로 저장되는 자료 구조인 Hash Table이나 B-tree를 이용하여 구현됨.
      - B-tree의 변형으로 구현되는 경우도 많은데, MySQL은 B-tree의 변형인 B+tree를 이용하여 복잡하게 구현됨

    - 인덱스가 너무 많으면 좋지않음 + 3~4개가 적당하다고 함
      - 너무 많은 인덱스는 새로운 Row를 등록할때마다 인덱스를 추가해야하고, 수정/삭제 시마다 인덱스 수정이 필요하여 성능상 이슈
      - 위에서 말한것처럼 인덱스는 추가적인 공간을 사용함
      - 인덱스가 많으면 옵티마이저가 잘못된 걸 선택하고 인덱스를 잘못 태울 확률이 커짐

</details>

<br>

<details><summary>5-2. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요? (출처 : vsfe)</summary>

<br>

- 인덱스의 효과를 누리려면 인덱스를 항상 최신의 정렬 상태로 유지해야 해서, INSERT/UPDATE/DELETE문으로 인덱스가 적용된 컬럼이 수정되면 연산을 추가적으로 해야되는 오버헤드가 발생
    - INSERT : 새로운 데이터에 대한 인덱스 추가
    - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
    - UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
      - 실제로 인덱스에는 update가 없고, 그저 delete + insert 이다.

</details>

<br>

<details><summary>5-3. 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요? (출처 : vsfe)</summary>

- 사용하지 않음 처리를 했다는 말은 `DELETE`와 `UPDATE` 이후 기존 인덱스를 삭제하지 않고 사용하지 않음 처리 했다는 의미이다.

- 예를 들어, B+tree의 리프노트에 `(이름, 신재윤)`을 `(이름, 삭제된 data)`와 같이 표시해두는 것이다. 해당하는 삭제된 값을 무시하면서 노드를 따라 이동하며 원하는 값을 찾으면 되기에, 결국 정책은 그대로 따라간다는 의미이다.

- 이러한 이유로, `INSERT/UPDATE/DELETE` 작업이 많은 테이블에서는 index가 안좋다는 의미이다. 당장 데이터를 삭제할 때는 실제로 삭제하지 않고 마킹만 해두는 것이 좋겠지만, 이것들이 쌓이면 사용하지도 않는 작업이 공간을 차지하니까 좋지 않다.

</details>

<br>

<details><summary>5-4. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요. (출처 : vsfe)</summary>

<br>

- <ins><strong></strong></ins>

</details>

<br>

<details><summary>5-5. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>5-6. 외래키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 외래키는 어떤 차이가 있나요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>5-7. 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>5-8. 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>5-9. (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요? (출처 : vsfe)</summary>

</details>

<br><hr>

## 9번 질의

<details><summary>9-1. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요. (출처 : vsfe)</summary>

</details>

<br>

<details><summary>9-1. 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요. (출처 : vsfe)</summary>

</details>

<br>

<details><summary>9-1. 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>9-1. 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>9-1. 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요. (출처 : vsfe)</summary>

</details>

<br><hr>

## 15번 질의

<details><summary>15-1. Table Full Scan, Index Range Scan에 대해 설명해 주세요. (출처 : vsfe)</summary>

</details>

<br>

<details><summary>15-1. 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요? (출처 : vsfe)</summary>

</details>

<br>

<details><summary>15-1. COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요? (출처 : vsfe)</summary>

</details>

<br><hr>

## 참고 자료

- vsfe 님의 **[VSFE / Tech-Interview Github](https://github.com/VSFe/Tech-Interview/tree/main)**
- 망나니개발자 님의 **[[MySQL] 프라이머리 키(PK, Primary Key)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/285)**
- 망나니개발자 님의 **[[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)**
- 망나니개발자 님의 **[[Database] 인덱스(index)란?](https://mangkyu.tistory.com/96)**
- 기억보단 기록을 님의 **[[mysql] 인덱스 정리 및 팁](https://jojoldu.tistory.com/243)**
