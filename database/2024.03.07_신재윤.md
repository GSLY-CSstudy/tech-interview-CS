
# GSLY 면접스터디

**1주차 질문 목록**

- [1번 질의](#1번-질의)
- [2번 질의](#2번-질의)
- [6번 질의](#6번-질의)
- [7번 질의](#7번-질의)
- [8번 질의](#8번-질의)
- [13번 질의](#13번-질의)
- [참고 자료](#참고-자료)

<hr>

## 1번 질의

<details><summary><strong>1-1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요. (출처 : vsfe)</strong></summary>

- 키(key)는 데이터베이스에서 조건을 만족하는 튜플을 찾거나, 순서대로 정렬할 때 <ins>**다른 튜플들과 구별할 수 있는 유일한 식별자이다.**</ins>

- key는 하나의 key 값으로 튜플을 유일하게 식별할 수 있는 성질인 <ins>**유일성**</ins>과 키를 구성하는 속성들 중 가장 최소로 필요한 속성들로만 키를 구성하는 성질인 <ins>**최소성**</ins>이라는 속성을 가진다. 

- 슈퍼키, 후보키, 기본키, 대체키, 유일키, 외래키가 있다.

<p align="center">
<img src="./image/2024.03.07-신재윤-image01.png" height="50%", width="75%">
</p><br>

- **슈퍼키 (Super Key)**

    - 릴레이션(테이블)에서 튜플(행)을 유일하게 식별할 수 있는 하나 이상 속성들의 집합

    - 유일성 O, 최소성 X

    - <details><summary>ex) <code>PLAYER(id, name, team_id, back_number, birth_date)</code> 릴레이션에서 슈퍼키를 찾으시오.</summary><ul><li><code>{id, name, team_id, back_number, birth_date}</code><ul><li>릴레이션의 정의 자체가 튜플들로 이루어진 집합이니까 중복자체를 허용하지 않아서 전체 attributes set 자체로 superkey가 될 수 있음</li></ul></li><li><code>{id, name}</code> <strong>,</strong> <code>{name, team_id, back_number}</code> ****.. 기타 등등</li></ul></details>

- **후보키 (Candidate Key)**

    - 기본키가 될 수 있는 후보로 선정된 키

    - 어느 하나의 속성이라도 제거하면 유일하게 튜플(행)을 식별할 수 없는 슈퍼키, minimal superkey 라고도 함

    - 유일성 O, 최소성 O

    - <details><summary>ex) <code>PLAYER(id, name, team_id, back_number, birth_date)</code> 릴레이션 에서 후보키를 찾으시오.</summary><ul><li><code>{id}</code><ul><li>id는 이미 attribute가 1개니까 제거할 수 없음, 후보키</li></ul></li><li><code>{team_id, back_numer}</code><ul><li>이 둘 중 하나라도 없애면 각각 하나하나는 유니크하게 튜플들을 식별할 수 없음, 후보키</li></ul></li></ul></details>

- **기본키 (Primary Key)**

    - 릴레이션(테이블)에서 튜플(행)을 유일하게 식별하기 위해 선택된 후보키
    
    - 릴레이션에서 기본키는 단 1개

    - <details><summary>ex) <code>PLAYER(id, name, team_id, back_number, birth_date)</code> 릴레이션 에서 개인키를 찾으시오.</summary><ul><li><code>{id}</code> 혹은 <code>{team_id, back_number}</code> 둘 중 하나를 <strong>개인키</strong>로 선택</li><li>보통 attributes 수가 적은 경우를 pk로 선택 많이함. 여기서는 <strong><code>{id}</code></strong> 선택</li><li>pk는 보통 밑줄 그어서 표시</li></ul></details>

- **유일키 (Unique Key)**

    - 후보키 중 선택받지 못한 키로, 대체키(alternate key) 라고도 부름

    - <details><summary>ex) <code>PLAYER(id, name, team_id, back_number, birth_date)</code> 릴레이션 에서 유일키를 찾으시오.</summary><ul><li>id가 pk로 선택된 경우에 <strong>유일키(=대체키)</strong> 는 <code>{team_id, back_number}</code></li></ul></details>

- **외래키 (Foreign Key)**

    - 다른 릴레이션의 기본키를 참조하는 속성들의 집합

    - <details><summary>ex) <code>PLAYER(id, name, team_id, back_number, birth_date)</code> , <code>TEAM(id, name, manger)</code> 두 릴레이션 중에서 외래키를 찾으시오.</summary><ul><li>여기서 <strong>외래키</strong>(foreign key)는 PLAYER의 <strong><code>{team_id}</code></strong></li></ul></details>

- **복합키 (Composite Key)**

    - 각 튜플(행)을 식별할 수 있는 두 개 이상의 속성들로 구성된 후보키

    - <details><summary>슈퍼키와 복합키의 차이</summary><p><p>슈퍼키와 복합키의 차이는 “구성하고 있는 키가 어떤 키인지”</p></p><ul><li>슈퍼키 : 구성되는 키가 후보키에 들어가지 않는다. 예를 들어, <code>(학번 + 이름)</code> 의 경우 학번은 기본키로 후보키의 범주이지만, 후보키는 중복 가능</li><li>복합키 : 구성되는 키가 모두 후보키에 속한다. 예를 들어, <code>(학번 + 강의코드)</code> 의 경우 학번으로 학생 구별 가능하고 강의 코드로 강의 구별 가능하다. 중복된 값을 허용하기 위해 2개의 후보키를 복합키로 하여 기본키를 생성한 형태이다.</li></ul></details>

</details>

<br>

<details><summary><strong>1-2. 데이터베이스에서 키가 필요한 이유가 무엇인가요?  (창작 문제)</strong></summary>

- 데이터베이스에서 레코드의 순서에는 의미가 없는데, 이때, 이를 구분해주기 위하여 필요한 것이 바로 키(key)이다.

- RDB에서 특정 레코드를 구별하거나 탐색하기 위한 유일한 방법이 key이다. 따라서, 데이터를 사용하려면 키는 무조건 필요하다.

- 키(key)는 데이터 정합성 유지, 검색, 수정, 삭제 등의 작업을 수행할 때 중요한 역할

    - 데이터 정합성이란, 데이터가 올바르고 일관성 있게 유지되는 것

</details>

<br>

<details><summary><strong>1-3. 기본키는 수정이 가능한가요? (출처 : vsfe)</strong></summary>

- 기본키 역시 update를 통하여 수정 가능하다. 단, unique 한 값이어야 한다.

- 또, 기본키의 경우 다른 테이블에서 참조할 수도 있기 때문에 조심해야 한다.

    - cascade 설정 X 연관관계에 있는 → 기본키 or 외래키 수정 불가

    - cascade 설정 O 연관관계에 있는 → 기본키 수정 O, 기본키가 다른 테이블의 외래키로 설정되어 있으면 그 외래키까지 함께 수정됨

    - cascade 설정 O 연관관계에 있는 외래키는 수정 불가

</details>

<br>

<details><summary><strong>1-4. 기본키를 수정할 수 있다면, 고려해야하는 사항은 무엇인가요? (창작 문제)</strong></summary>

- PK는 레코드의 물리적인 저장 위치를 결정하기에, 단순히 UPDATE로 값만 변경하면  레코드가 본래 있어야 하는 페이지가 달라질 수 있다.

- 따라서, 레코드를 DELETE 한 이후 INSERT 해줘야 한다.

    - 2번의 디스크 I/O 작업이 필요하고, 인덱스 쪽에도 추가 작업을 유발할 수 있어서 비용이 상당히 크므로 PK는 변하지 않는 값으로 설정하는 것이 중요하다.

</details>

<br>

<details><summary><strong>1-5. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요? (출처 : vsfe)</strong></summary>

- MySQL은 기본적으로 PK가 클러스터 인덱스이며, PK가 없으면 내부적으로 PK를 만들어내기에 가능하다.

    - PK가 없으면 NOT NULL 옵션의 유니크 인덱스(레코드마다 값이 고유한) 중에서 첫번째 인덱스를 클러스터링 키로 선택함

    - 만약, 이도 없다면 InnoDB가 자체적으로 자동 증가 유니크 컬럼을 추가한 후 클러스터링 키로 선택

        - 이렇게 자동 생성되는 내부 PK는 사용자에게 노출되지 않으며, 쿼리에서 사용할 수도 없음. 클러스터 인덱스는 테이블 당 단 하나만 가질 수 있으므로 반드시 생성해주는 것이 좋다.

</details>

<br>

<details><summary><strong>1-6. 인덱스, 클러스터 인덱스, 논클러스터 인덱스가 무엇인가요? (창작 문제)</strong></summary>

- <ins>**인덱스 (Index)**</ins> : 추가적인 쓰기 작업과 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

    - 데이터베이스 테이블의 검색 속도를 향상시키기 위해 사용하는 것으로, 시스템 부하를 줄여 시스템 전체 성능향상에 기여하는 것

    - 인덱스를 위해 DB 10% 내외의 추가 공간이 필요하다. 따라서, 데이터가 많으면 인덱스 생성에 많은 시간이 소요될 수 있음

    - 인덱스를 사용하지 않은 컬럼을 조회하려면 전체를 비교하며 탐색(Full Scan)해야 해서 처리 속도가 떨어짐

    - 조희 성능은 좋으나, 오히려 삽입/수정/삭제 등의 경우 오히려 성능이 저하됨

        - 인덱스에 관련된 추가 연산을 해야하기 때문
        - INSERT : 새로운 데이터에 대한 인덱스 추가
        - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
        - UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가

- <ins>**클러스터 인덱스 (Clustered Index)**</ins> : 실제 데이터와 같은 무리의 인덱스, 해당 키 값을 기반으로 데이터 행을 정렬하고 저장하는 것으로, 클러스터 키가 정렬되어 있고, 정렬된 순서에 따라 데이터의 주소가 결정됨

    - ex) 실제 데이터가 정렬된 백과사전

    - 데이터는 오직 하나의 순서로 정렬될 수 있어서 클러스터 인덱스는 테이블당 최대 1개만 존재

    - 리프 페이지가 데이터 페이지

- <ins>**논-클러스터 인덱스 (Non-Clustered Index)**</ins> : 실제 데이터와 다른 무리의 별도의 인덱스, 논클러스터 인덱스 키 값을 가지고, 그 키 값의 레코드는 실제 키 값의 레코드를 향한 포인터를 가짐

    - ex) 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지 (책 맨 뒤에 그거)

    - 실제 데이터 페이지는 그대로 있음

    - 별도의 인덱스 페이지 생성 → 추가 공간 필요

    - 테이블 당 여러 개 존재 가능

    - 리프 페이지에 실제 데이터 페이지 주소를 담고 있음

    - unique 제약조건 적용 시 자동 생성

    - 직접 index 생성시 논-클러스터링 인덱스 생성

</details>

<br>

<details><summary><strong>1-7. 리프 페이지라고 하셨는데, 페이지(Page)가 어떤 것인가요? (창작 문제)</strong></summary>

- 페이지란, 디스크와 버퍼풀(메모리)에 데이터를 읽고 쓰는 최소 작업 단위

- 일반적인 인덱스를 포함해, PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리됨. 루트 페이지는 리프 페이지의 주소로 구성하고, 리프 페이지는 실제 데이터 페이지로 구성

- 아래는 클러스터링 테이블의 저장 방식이다. PK는 인덱스처럼 별도의 자료구조에서 관리가 된다. 리프 페이지에 실제 레코드의 모든 컬럼 값이 저장되어 있다는 것을 제외하면 일반적인 인덱스와 동일

<p align="center">
<img src="./image/2024.03.07-신재윤-image02.png" height="50%", width="75%">
</p><br>

</details>

<br>

<details><summary><strong>1-8. MySQL에서 PK를 신중하게 결정해야하는 이유는 무엇일까요? (창작 문제)</strong></summary>

- <ins>**PK가 레코드의 물리적인 저장 위치를 결정**</ins>하기 때문이다.

- MySQL은 PK를 기준으로 유사한 값들이 함께 조회되는 경우가 많다는 점에서 착안하여, <ins>**PK가 유사한 레코드들끼리 묶어서 저장**</ins>한다.

- 유사한 것들을 묶는 것을 클러스터링이라고 하는데, 일반적으로 <ins>**PK는 클러스터 인덱스 (Clustered Index)**</ins> 라고 불린다. (그 외의 일반적인 인덱스는 논클러스터 인덱스)

- 클러스터링 특성 때문에 레코드의 저장이나 PK의 변경은 처리 속도가 느림
    - 레코드를 추가하기 위해 <ins>**PK 기반으로 레코드의 저장 위치를 탐색해야하기 때문**</ins>
    - 또, PK를 변경하는 것은 <ins>**레코드가 저장된 물리적인 위치를 변경하는 작업이 수반됨**</ins>

</details>

<br>

<details><summary><strong>1-9. 클러스터링 특성 때문에 단점이 많아 보이는데, 그럼에도 MySQL에서 채택한 이유는 무엇이라고 생각하세요? (창작 문제)</strong></summary>

- 쓰기(Write) 작업을 희생해서라도 빠르게 읽기(Read) 작업을 처리하기 위함

- 일반적인 온라인 환경에서 읽기와 쓰기의 비율이 8:2, 9:1 정도라서 읽기 작업을 더욱 우선시 한 것

</details>

<br>

<details><summary><strong>1-10. 외래키 값은 NULL이 들어올 수 있나요? (출처 : vsfe)</strong></summary>

- 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 하는 <ins>**참조 무결성 제약조건**</ins>에 의해 들어갈 수 있다.

- ex) 사원이 하나의 부서를 가지는 경우인데, 신입사원은 아직 부서가 미정

</details>

<br>

<details><summary><strong>1-11. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요? (출처 : vsfe)</strong></summary>

- 정의에 unique 키워드를 적용시키면, 칼럼에 자동으로 논클러스터 인덱스가 적용되는 것이다.

- 적용시키지 않은 경우, 기본이라고 가정한다면 전체 테이블 스캔(Full Table Scan)을 할 것이고 논클러스터 인덱스의 경우 인덱스 스캔(Index Scan)을 할 것이다.

- 데이터가 별로 없는 규모가 작은 테이블, `INSERT/UPDATE/DELETE`가 자주 발생하는 칼럼, `WHERE, JOIN, ORDER BY`와 같은 조건절이 자주 사용 안되는 칼럼, 카디널리티(중복도)가 높은 칼럼 → <ins>**전체 테이블 스캔이 더 빠름**</ins>

- 데이터가 많아서 규모가 큰 테이블, `INSERT/UPDATE/DELETE`가 자주 발생하지 않는 칼럼, `WHERE, JOIN, ORDER BY` 와 같은 조건절이 자주 사용되는 컬럼, 카디널리티(중복도)가 낮은 칼럼 → <ins>**인덱스 스캔이 더 빠름**</ins>

</details>

<br>

### 2번 질의

<details><summary><strong>1-2. 데이터베이스에서 키가 필요한 이유가 무엇인가요?</strong></summary>



</details>