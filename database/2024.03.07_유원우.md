# 기본키는 수정이 가능한가요?

기본키는 수정할 수 있습니다. 하지만 기본키는 테이블 내 각 행을 고유하게 식별하기 때문에 수정 시 중복되거나 null값일 수 없습니다. 또한 해당 키를 참조하는 외래키가 있는 경우, 외래키의 데이터도 함께 업데이트 해야 합니다.

**개체 무결성**: 기본키를 구성하는 속성은 null 값이나 중복된 값을 가질 수 없다.   
**참조 무결성**: 외래키 값은 null이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다.

# 기본키를 설정하지 않아도 테이블이 만들어지는 이유는 무엇인가요?

데이터베이스는 기본키를 강제하지 않습니다.(아마도 임시 테이블이나 데이터 분석의 경우 기본키가 필요하지 않을 수 있기 때문에)   
하지만 기본키를 설정하지 않으면 중복된 데이터가 존재할 수 있고 기본키 인덱스를 사용할 수 없어 조회시 성능이 떨어질 수 있음을 인지해야 합니다.(분석 테이블인 경우 전체 조회만 한다면 필요 없을 수 있지만 중복 데이터를 판별할 수 없어 개인적으로 기본키를 만드는 것이 바람직하다고 생각함)

# 외래키 값은 NULL이 들어올 수 있나요?

null을 허용합니다. 외래키는 다른 테이블 행을 참조하는 관계를 나타내주는 키인데 참조하는 테이블이 없을 경우 null을 사용할 수 있습니다.

# UNIQUE 키워드가 붙은 칼럼을 활용한 쿼리의 성능은 어떻게 다를까요?

Mysql 기준 `UNIQUE` 제약조건을 적용하면 자동으로 인덱스를 생성합니다. 이 인덱스를 이용하여 `UNIQUE` 키워드가 붙은 컬럼을 활용한 쿼리는 전체 테이블 스캔보다 빠르게 결과를 반환합니다.


--- 


# NoSQL의 강점과, 약점이 무엇인가요?

### 강점
NoSQL은 특정 상황에 특화된 데이터베이스라고 생각합니다.   
- 아주 낮은 응답 지연시간이 요구되는 경우(키-값 저장소)
- 관계형 데이터베이스가 필요하지 않은 경우
- 데이터를 직렬화, 역직렬화만 하는 경우
- 아주 많은 양의 데이터를 저장할 필요가 있는 경우
등의 특성이 필요한 경우 사용할 수 있을 것 같습니다.

### 약점
NoSQL은 RDBMS에 비해 짧은 기간 사용되었으므로 안정성을 검증해야 할 수 있습니다.

# RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)

데이터의 구조가 정의되어 있는 특징과 Join 연산 때문에 많이 발생한다고 생각합니다. 
데이터를 삽입, 삭제시 무결성을 보장하기 위한 작업이 추가로 들거나 테이블이 정규화 되어 있어 select 시에 join을 통해 많은 행들을 만들고 추출하는 과정에서 느려질 수 있습니다.

# NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

X


---

# 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

**클러스터링(Clustering)**: RDBMS를 여러 서버가 같은 데이터베이스 스토리지를 관리하여 고가용성과 부하 분산을 제공하는 방식입니다. 고가용성과 부하를 분산시킬 수 있습니다.   
(같은 데이터베이스 스토리지를 바라보므로 병목이 발생할 수 있다)

**레플리케이션(Replication)**: 데이터를 주 서버(Master)와 하나 이상의 보조 서버(Slave)로 복사하는 과정입니다.   
주 서버에서 복제 서버로 데이터를 복제해서 읽기 쿼리 부하를 분산시켜줍니다.   
(서로 다른 데이터베이스 스토리지를 사용하여 성능을 뽑아낼 수 있지만 데이터 불일치가 발생할 수 있다)

# 분산 환경에서 트랜잭션을 어떻게 관리할 수 있을까요?

크게 동기 방식과 비동기 방식 있습니다.

### 동기
마스터에서 슬레이브로 데이터가 복제가 트랜잭션을 완료하지 않는 방식입니다. 이는 데이터 정합성은 일치시켜줄 수 있지만, 성능에 영향을 줄 수 있습니다.

### 비동기
마스터에 삽입시에는 트랜잭션과 슬레이브의 복제를 별개로 가져가는 방식입니다. 성능은 좋아지지만 마스터와 슬레이브의 데이터 불일치가 발생할 수 있습니다.

# 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

샤딩은 데이터베이스를 여러 조각으로 수평 분할하는 방식입니다. 각 샤드는 데이터베이스의 서브셋들을 독립적으로 관리합니다.

제가 생각하는 두 방식의 주된 차이점은 데이터 스토리지가 복제되어 있는가, 분리되어 있는가입니다.
복제되어 있다면  안정성과 가용성 이점을 가져갈 수 있고 분리되어 있다면 대용량 데이터 연산과 쓰기 연산 이점을 가져갈 수 있습니다.
안정성과 가용성이 중요하다면 레플리케이션 방식, 대용량 처리와 쓰기 연산이 중요하다면 샤딩 방식을 택하겠습니다.

# 정규화가 무엇인가요?

데이터 중복과 데이터 무결성을 높여 데이터베이스를 보다 효율적으로 관리할 수 있게 테이블을 분리하는 과정입니다.

# 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.

- 삽입 이상(Insertion Anomaly): 불필요한 데이터도 함께 저장하는 경우
- 삭제 이상(Deletion Anomaly): 연관되어 있어 삭제하면 안되는 다른 정보도 함께 삭제하는 경우
- 갱신 이상(Update Anomaly): 중복 데이터로 인해 데이터 간 불일치가 발생하는 경우

# 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.

- 1NF: 비원자적인 항목이 존재 -> 모든 칼럼이 원자값으로 구성
- 2NF(부분 함수 종속성): 기본키가 복합키인 경우 특정 칼럼이 복합키 전부가 아닌 일부만에 종속되어 있음 -> 모든 비키 칼럼이 기본비 전체에 종속되도록 분리
- 3NF(이행적 함수 종속성): 비키 칼럼이 비키 칼럼에 종속되어 있음 -> 모든 비키 칼럼이 기본키에만 종속됨
- BCNF: 기본키 일부가 다른 기본키 일부를 결정하는 경우 -> 모든 결정자가 후보키가 되도록 분리

# 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.

정규화는 무결성을 지키게 해주지만 비즈니스 로직상 함께 참조되는 테이블들이 존재할 경우 반복되는 join 연산이 발생하여 쿼리 성능 저하를 일으킬 수 있습니다.(반대로 같은 테이블 컬럼이지만 따로 필요한 경우 필요하지 않은 컬럼도 같이 메모리에 올릴 수 있음)


---


# View가 무엇이고, 언제 사용할 수 있나요?

View는 데이터베이스 내에 실제로 저장되어 있는 테이블로부터 유도된 가상의 테이블입니다.

- 복잡한 쿼리를 View로 만들어두어 간단히 사용
- 사용자에게 특정 데이터만 보여주는 용도(보안)

# View의 값을 수정해도 실제 테이블에는 반영되지 않나요?

view에 테이블 칼럼 정보가 있을 경우 반영됩니다. 하지만 view의 주된 목적은 조회라고 생각하여 위험하다고 생각합니다.


---


#  Schema가 무엇인가요?

데이터베이스 구조를 정의하는 틀입니다.

# Schema의 3계층에 대해 설명해 주세요.

- 외부 스키마(External Schema): 사용자 관점의 데이터베이스 정의, 예) View
- 개념 스키마(Conceptual Schema): 데이터베이스 구조와 정책(데이터 타입, 관계, 제약 조건)
- 내부 스키마(Internal Schema): 물리적인 데이터 저장 관점, 실제로 저장되는 방식
