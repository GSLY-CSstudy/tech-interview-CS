**5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

인덱스는 책의 색인이고 책의 내용은 데이터 파일에 해당된다. DBMS가 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 따라서 칼럼의 값과 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 둔다. 

- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
    - 인덱스는 데이터의 저장(insert, delete, update) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 테이블 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.
    - B-Tree 저장될 때 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다. 그리고 리프 노드가 꽉 차서 더는 저장할 수 없을 때 리프 노드가 분리되어야 하는데 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 따라서 B-Tree는 상대적으로 쓰기 작업 비용이 많이 든다.
    - 인덱스 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요한데 이 작업은 디스크 I/O가 발생하므로 InnoDB 스토리지 엔진에서는 버퍼링되거나 지연 처리된다.
    - B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리된다.
- (+) InnoDB는 인덱스 쓰기 지연을 지원합니다. 어떠한 방식으로 지원할까요?
    - 체인지 버퍼로 지원한다.
    - 레코드가 insert, update될 때 해당 테이블에 포함된 인덱스를 업데이트하는 작업이 필요하다. 이 작업은 랜덤하게 디스크를 읽어야 하므로 테이블에 인덱스 많다면 많은 자원이 소모된다.
    - 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트 수행되지만 디스크로부터 읽어와야 한다면 체인지 버퍼라는 임시 메모리에 저장된다. (인덱스 쓰기 지연) 다만 결과 전달 전 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼 사용 불가하다.
- 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
    - MySQL의 InnoDB의 경우 프라이머리 키에 대해 자동적으로 클러스터링 인덱스를 만든다. 프라이머리 키가 없다면 not null 옵션의 유니크 인덱스 중 첫 번째를, 아니면 내부적으로 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 클러스터링 키로 선택한다.
- ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
    - order by에 명시된 칼럼이 드라이빙 테이블에 속하고, order by 순서대로 생성된 인덱스가 있으면 인덱스를 사용해 정렬한다. 그렇지 않으면 filtesort를 사용하여 정렬한다.
    - 인덱스는 생성될 때 설정한 정렬 규칙에 따라서 정렬된다. 옵티마이저는 인덱스를 정순으로 혹은 역순으로 읽을 수 있다. 다만 인덱스를 역순으로 읽는 것은 정순으로 읽는 것보다 느리다.
    - 참고로 MySQL 8.0부터는 정렬 순서를 혼합(asc와 desc 혼합)하여 인덱스를 생성할 수 있게 되었다.
    - 조인에서 드라이빙 테이블에 속한 칼럼만을 이용해 그루핑할 때 group by 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
    - 아니다. 튜플을 식별할 목적으로 데이터베이스 설계자가 공식적으로 선택하여 지정한 키를 기본키라고 한다. 기본키는 엄밀히 말하면 contraint 제약조건이다. pk에는 자동으로 인덱스가 걸린다.
- 그렇다면 외래키는요?
    - 외래키는 다른 테이블의 PK나 key를 가리킬 목적으로 생성된 속성(attribute)이다. 외래키도 pk와 마찬가지로 제약 조건이며 pk와 다르게 자동으로 인덱스가 걸리지 않는다.
- 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
    - MySQL의 InnoDB에서 클러스터링 인덱스는 데이터 물리적 저장에도 영향을 미친다. 프라이머리 키를 기준으로 테이블의 레코드를 비슷한 것끼리 묶어서 저장한다.
- 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
    - RDB는 데이터를 저장하기 위해 계층적 구조인 B-Tree 인덱스를 사용한다. 반면 NoSQL은 키-값 저장소에 데이터를 저장하는 해시 인덱스를 사용한다.
    - B-Tree 인덱스는 데이터가 순서대로 저장 되므로 특정값을 쉽게 검색할 수 있다. 하지만 수정 및 삽입할 경우 삽입할 데이터의 올바른 위치를 찾기 위해 많은 시간이 소요 된다.
    - 반면 해시 인덱스는 데이터를 어떤 순서로든 저장할 수 있다. 따라서 관련된 키만 찾으면 되므로 수정 및 삽입이 빨라진다. 다만 검색이 어려울 수 있다.
- + 그렇다면 RDB는 해시 인덱스를 지원하지 않는가?
    - MySQL의 InnoDB는 어뎁티브 해시 인덱스를 지원한다. InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.
    - B-Tree의 검색 시간 줄여주기 위해 도입되었고 B-Tree를 루트 노드부터 리프 노드까지 찾아가는 비용을 없애기 위함이다.
    - 어댑티브 해시 인덱스는 **버퍼 풀에 올려진 데이터 페이지에 대해서만 관리**한다. 따라서 버퍼 풀에서 해당 페이지 정보가 없어지면 어댑티브 해시 인덱스에서도 사라진다.
- (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
    - 인덱스를 구성하는 칼럼의 순서가 매우 중요하다. (A, B)와 같은 방식으로 인덱스를 선택했을 때 where 조건절에 A에 대한 비교 조건이 없는 쿼리는 인덱스를 사용할 수 없다. B부터 시작하는 인덱스를 새로 생성해야 한다.
    - MySQL 8.0부터는 옵티마이저가 A를 건너뛰고 B 칼럼만으로 인덱스를 검색이 가능하게 해주는 인덱스 스킵 스캔 기능이 도입됐다. MySQL 옵티마이저가 우선 A 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 B 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.
9. **DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

필요한 데이터끼리 결합할 때 조인join이라는 방식을 사용한다.

내부 조인은 양쪽 테이블에 같은 데이터가 있을 때만 결합하는 방식이다.

왼쪽 외부 조인, 오른쪽 외부 조인은 각각 어느 한쪽에만 데이터가 있어도 데이터를 결합하는 방식이다.

어느 한쪽에도 해당 사항이 없을 때는 전체 외부 조인이라고 하며 지원하지 않는다.

- 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
    - 다수의 테이블에서 조인을 수행할 때 동시에 여러 개의 테이블에 접근할 수 없다. 따라서 접근 우선 순위를 정한다. 이때 테이블의 접근하는 선후 관계에 따라 드라이빙 테이블과 드리븐 테이블이라는 용어로 구분한다.
    - 조인 수행하는 알고리즘에는 중첩 루프 조인, 블록 중첩 루프 조인, 배치 키 엑세스 조인, 해시 조인이 있다.
    - 중첩 루프 조인은 드라이빙 테이블의 데이터 1건 당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력한다.
    - 드리븐 테이블에 인덱스가 없을 경우 매번 드리븐 테이블을 풀 테이블 스캔해야 한다. 이러한 비효율적인 방식을 없애기 위해 드라이빙 테이블에 조인 버퍼(join buffer)를 도입하여 중첩 루프 조인의 효율성을 높이고자 블럭 중첩 루프 조인이 탄생했다.
    - 중첩 루프 조인은 데이터 접근 시 인덱스에 의한 랜덤 엑세스가 발생하므로 엑세스할 데이터의 범위가 넓다면 비효율적이다. 따라서 이러한 랜덤 엑세스의 단점을 해결하고자 접근할 데이터를 미리 예상하고 가져오는 방식인 배치 키 엑세스 조인이 등장했다.
    - 드리븐 테이블의 데이터를 예측하고 정렬된 상태로 버퍼에 적재하는 기능인 다중 범위 읽기(MRR)을 수행한다.
    - 해시 조인은 MySQL 8.0.18버전부터 지원된다. 블록 중첩 루프 조인과 배치 키 엑세스 조인의 한계를 탈피한다. 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다.
- 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
    - 실행계획의 extra 컬럼을 보면 조인 버퍼를 사용할 경우 Using join buffer가 나타난다. 이때 조인 버퍼가 어떻게 사용되는지 알 수 있다.
- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
    - 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 드라이빙 테이블에 일치하는 레코드 수만큼 풀테이블 스캔을 한다. 따라서 매우 느려진다.
- 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.
    - MySQL에서 인덱스 여부로 조인의 순서가 결정되고, 테이블 및 인덱스 통계 정보를 사용해 레코드가 적은 테이블을 드라이빙으로 선택한다.
    - 만약 순서를 지정해주고 싶다면 straight_join과 같은 힌트를 사용하면 된다.

**15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다. 보통 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. 그래서 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한 번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정 됐을 때 사용한다. B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고 그 지점부터 필요한 방향으로 인덱스를 읽어나간다. 어떤 방식으로 스캔하든 관계없이 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태의 레코드를 가져온다. 

인덱스의 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번 씩 일어난다.

- 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
    - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔이 더 빠른 경우
    - where이나 on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(*), COUNT(column) 의 동작 과정에는 차이가 있나요?
    - *을 주게 될 경우 내부적으로 값을 확인하지 않고 단지 행의 개수만 본다.
    - 반면 1, column을 명시할 경우 null 값은 카운팅에서 제외되고 null 체크를 한다.
    - MyISAM의 경우 내부적으로 count()값이 저장되어 빠르다고 하지만 innodb에서는 테이블의 현재 row를 정확히 확인할 수 없다고 한다. 따라서 innodb에서 count(*)과 count(1)의 작동방식은 같으며 성능적으로 다를게 없다.

출처 : 쉬운코드 블로그 (https://easy-code-yo.tistory.com/44), RealMySQL 8.0 1권, https://www.enterprisenetworkingplanet.com/data-center/sql-vs-nosql/, 업무에 바로 쓰는 SQL 튜닝
