# JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

객체 지향 프로그래밍과 관계형 데이터베이스의 불일치를 해결하기 위함입니다.(불일치는 데이터를 다루는 방식의 차이를 말함)

- 생산성 증가: 객체 -> 관계형 데이터로 매핑하는 과정을 자동으로 처리해주므로 반복되는 번거로움을 줄일 수 있습니다.
- 하드 코딩의 위험성 줄어듬: 변환하는 과정에서 SQL 쿼리를 작성해야 하므로 하드코딩이 일어납니다. 이 과정을 ORM이 대신해주므로 하드코딩의 위험성이 감소합니다.
- 트랜잭션 관리와 캐싱: 대부분의 ORM이 매핑 뿐만 아니라 트랜잭션 관리와 캐싱 메커니즘을 제공해주므로, 작업의 성능과 일관성을 향상시킬 수 있습니다.

## 객체 지향 프로그래밍과 관계형 데이터베이스의 불일치를 해결하는 다른 방법에는 어떤 것들이 있을까요?

- SQL Mapper(MyBatis): SQL문과 자바 코드를 별도로 관리하기 편하다. SQL문을 직접 작성하여 JPA보다 배우기 쉽고 발생되는 문제도 찾기 쉬울 수 있지만, SQL 직접 작성으로 인한 반복 작업과 데이터베이스에 종속적이다.
- 객체를 그대로 직렬화 할 수 있는 데이터베이스 사용: 문서 지향형 데이터베이스(MongoDB) 등

## MyBatis이 필요한 경우

잘 설계된 데이터베이스와 프로젝트라면 JPA가 편할 수 있습니다. 하지만 그렇지 않을 경우 예측 불가능성이 높아집니다. 이 경우 마이바티스가 적절할 수 있습니다.   
또한, JPA는 공부해야 될 양이 많아 팀의 숙련도에 따라 적용하기 어려울 수 있습니다.

[JPA Mybatis 중 실무에서 많이 사용하는 기술과 이유를 알고 싶어요](https://okky.kr/questions/1482816?topic=questions&page=1&keyword=mybatis)

## JPA를 사용할 때 나타날 수 있는 성능 이슈

- N + 1 문제
- 즉시 로딩: 필요하지 않은 데이터도 즉시 로딩으로 불러와 성능 저하를 일으킬 수 있습니다.
- 대량 데이터 처리: 데이터베이스에서의 연산이라고 생각하는 쿼리가 메모리에 적재하여 추가 연산을 하는 경우가 있습니다. 이 때 메모리 초과 에러(OutOfMemoryError)가 발생할 수 있습니다.

## JPA 영속성은 어떤 기능을 하나요?

JPA 영속성은 엔티티 객체의 생명 주기를 관리합니다. 애플리케이션과 데이터베이스 사이의 가상의 캐시 데이터베이스를 두어 캐시 데이터베이스 사용, 쓰기 지연, 변경 감지 등의 기능을 제공해줍니다.   

### 이게 진짜 성능 향상에 큰 도움이 되나요?

- 캐시 데이터베이스: 이미 로드된 엔티티를 캐시 데이터베이스에서 가져옵니다. 캐시 데이터베이스를 사용하여 직접적인 데이터베이스 접근이 감소합니다. 
- 쓰기 지연: update, delete, insert 등의 쿼리를 모아 한번에 날릴 수도 있습니다. 데이터베이스와 통신하는 횟수를 줄여줍니다.

## N + 1 문제에 대해 설명해 주세요.

1번의 쿼리만을 에상했지만, N + 1개의 쿼리가 나가는 것을 말합니다.   
대량의 데이터를 조작할 때 발생합니다. 쿼리가 어떻게 동작하는 지에 대해 잘 알고 있어야 합니다.

### 해결 방법

- select
    - fetch join
    - batch size
- update, delete, insert시
    - 벌크 연산

---

# @Transactional 은 어떤 기능을 하나요?

트랜잭셔널 어노테이션을 메서드나 클래스에 적용하면 해당 범위 내에 실행되는 코드를 트랜잭션 경계 내에서 실행하도록 관리합니다.   
트랜잭션을 시작하고, 메서드가 성공적으로 완료되면 커밋, 예외가 발생하면 트랜잭션이 롤백됩니다.

## 장단점

### 장점
- 반복되는 코드 제거: 매번 트랜잭션을 적용할 때 반복되는 코드를 어노테이션으로 관리함으로써 중복된 코드를 제거합니다.

### 단점
- 트랜잭셔널 어노테이션이 붙은 클래스는 프록시 빈으로 감싸 만들어집니다. 그래서 내부에서 내부 참조,priavte 메서드엔 적용이 불가능합니다.

## @Transactional 을 사용할 때 주의할 점

- public 메서드: 일반적으로 트랜잭셔널 어노테이션은 public에 사용합니다. protected, private, package-private(default) 에서는 적용이 되지 않을 수 있습니다. 사용시 이점을 주의해야 합니다.
- 다른 AOP 기능과의 충돌: AOP 기능을 사용하면 프록시 빈으로 만듭니다. 이 때 트랜잭셔널 어노테이션을 다른 AOP 기능과 함께 사용하면, 올바르지 않게 동작할 수 있습니다. Order를 이용해 순서를 적용하거나 분리하는 등 조치를 취해야 합니다.


[@Transactional 바르게 알고 사용하기](https://medium.com/gdgsongdo/transactional-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-7b0105eb5ed6)


## @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?

readonly=true 설정을 하면, 데이터베이스 연결을 읽기 전용 모드로 합니다.   
데이터 변경시, 무시되거나 거부됩니다.   

### 성능 이점을 어떻게 가져오는가?

**JPA 관점**:   
- JPA 입장에서는 더티 체킹을 할 필요가 없습니다. JPA의 세션 플러시 모드를 MANUAL로 설정하여 사용자가 flush()를 수동으로 하게 만듭니다.
- 스냅샷을 생성하지 않습니다.

**데이터베이스 관점**:   
- 롤백 로그 등 변경을 대비할 필요가 없습니다. 변경 대비에 사용되는 불필요한 리소스를 줄입니다.

### 장점

- 데이터가 변경되는 것을 방지해줍니다.
- 변경하지 않음을 명시합니다.
- 데이터베이스 이중화시에 활용할 수 있습니다.

[MySQL 버전에 따른 @Transactional(readOnly=true)의 동작 과정](https://dkswnkk.tistory.com/740)   
[@Transactional 동작원리(+readOnly=true)](https://wookjongbackend.tistory.com/45)


## 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

트랜잭션을 걸지 않을 경우, 데이터 일관성 보장 받을 수 없습니다.

---

# Java 에서 Annotation 은 어떤 기능을 하나요?

자바에서는 어노테이션을 통해 메타데이터를 코드에 추가하는 방법을 제공합니다.   
코드 자체에는 영향을 미치지 않지만, 컴파일 타임이나 런타임에 유용한 정보로 제공할 수 있습니다.   

*메타데이터: 데이터에 대한 데이터, 다른 데이터를 설명하거나 분류, 이해할 수 있도록 하는 정보

## 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?

스프링은 Component Scan과 AutoConfiguration으로 특정 어노테이션들이 있는 클래스들을 등록하고 설절해줍니다.   
어노테이션은 원래 상속이 안됩니다. 하지만 스프링의 어노테이션은 특정 어노테이션을 적용할 때 해당 어노테이션을 적용하고 있는 모든 어노테이션을 고려하여 상속이 되는 것처럼 보입니다.

## Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

`getter`, `setter`, `equalsAndHashcode`, `toString` 등 많은 기능을 제공해주지만, 많은 기능을 제공해주어 발생할 수 있는 문제점들이 많습니다.   

- `setter`: 모든 필드가 변경 가능함
- `toString`: 모든 필드를 문자열로 출력합니다. 성능 저하 및 무한 루프에 빠질 가능성이 있습니다.
- `equalsAndHashcode`: 모든 필드로 계산됩니다. 계산시 시간이 오래 걸릴 수도 있고, 원하지 않게 동작할 수 있습니다.(이 또한 무한 루프 가능성 존재)
