# 운영체제

- 시스템 콜이 무엇인지 설명해주세요.
    
    시스템 콜은 운영체제의 커널에 있는 기능을 프로그램이 사용할 수 있도록 하는 인터페이스입니다. 시스템 콜을 통해 사용자 프로그램은 운영체제의 핵심 기능을 호출하여 파일 입출력, 프로세스 생성 및 제어, 메모리 할당 등과 같은 작업을 수행할 수 있습니다.
    
    - 우리가 사용하는 시스템 콜의 예시를 들어주세요.
        
        대표적인 예시 중 하나인 ‘open’은 파일을 열 때 사용됩니다. 사용자 프로그램은 ‘open’ 시스템 콜을 호출하여 파일을 열고, 운영체제는 해당 파일을 오픈하는데 필요한 작업을 수행합니다. 
        
        또 하나의 예로는 ‘exec’가 있습니다. ‘exec’ 시스템 콜은 새로운 프로세스를 현재 프로세스의 메모리 공간에 덮어씁니다. 주로 새로운 프로그램을 실행하는 데 사용됩니다. 예를 들어, C 언어로 작성된 프로그램에서 ‘exec’ 시스템 콜을 사용하여 다른 프로그램을 실행할 수 있습니다.
        
    
    - 시스템 콜이 운영체제에서 어떤 과정으로 실행되는지 설명해주세요.
        
        시스템 콜은 보통 다음과 같은 과정을 거쳐 실행됩니다.
        
        1. 사용자 프로그램이 시스템 콜을 호출합니다.
        2. 프로그램이 사용하는 언어나 API에 따라 시스템 콜 번호와 필요한 매개변수가 전달됩니다.
        3. 사용자 프로그램은 CPU 모드를 커널모드로 전환합니다.
        4. 커널은 시스템 콜을 처리하고 요청된 작업을 수행합니다.
        5. 작업이 완료되면 결과가 다시 사용자 프로그램으로 반환됩니다.
    
    - 시스템 콜의 유형에 대해 설명해 주세요.
        1. 프로세스 제어 : 프로세스의 생성, 종료, 중단, 상태확인 등과 관련된 작업을 수행합니다.
        2. 파일 관리 : 파일의 생성, 삭제, 읽기, 쓰기, 열기, 닫기 등과 같은 파일 입출력 작업을 수행합니다.
        3. 장치 관리 : 장치의 입출력 및 제어와 관련된 작업을 수행합니다.
    
    - 운영체제의 Dual Mode 에 대해 설명해 주세요.
        
        운영체제의 Dual Mode는 사용자 모드(User Mode)와 커널 모드(Kernel Mode)를 구분하는데 사용됩니다. 이는 보안과 안정성을 유지하기 위한 것입니다. 사용자 모드에서는 사용자 프로그램이 실행되고, 시스템 자원에 직접 접근할 수 없습니다. 대신, 커널 모드에서만 시스템 자원에 접근할 수 있습니다. 시스템 콜은 이러한 구조를 통해 사용자 모드와 커널 모드 간의 안전한 전환을 허용합니다.
        
    - 왜 유저모드와 커널모드를 구분해야 하나요?
        
        유저모드와 커널모드를 구분하는 이유는 보안과 안전성 때문입니다. 사용자 프로그램이 직접 시스템 자원에 접근할 경우 예기치 않은 동작이 발생할 수 있으며, 이는 시스템 전체의 안정성을 저해할 수 있습니다. 따라서, 운영체제는 시스템 자원에 대한 접근을 제한함으로써 안정성을 유지합니다.
        
    - 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
        
        시스템 콜을 구분하는 방법은 주로 시스템 콜 번호나 시그니처를 기준으로 합니다. 운영체제는 시스템 콜을 호출하는 프로그램이 전달한 요청을 분석하고, 해당하는 시스템 콜을 실행합니다. 이 때, 시스템 콜 번호를 확인하여 어떤 작업을 수행할지 결정하게 됩니다. 종종 시스템 콜은 고유한 시그니처나 이름을 가지고 있어 이를 통해 구분할 수도 있습니다.
        
- 인터럽트가 무엇인지 설명해주세요.
    
    인터럽트(Interrupt)는 컴퓨터 시스템에서 발생한 이벤트나 조건 변화를 처리하기 위해 CPU가 현재 수행 중인 작업을 중단하고, 인터럽트 서비스 루틴(Interrupt Service Routine, ISR)이나 핸들러를 실행하는 것을 말합니다. 인터럽트는 주로 하드웨어 디바이스나 소프트웨어가 발생시키며, CPU가 이에 반응하여 해당 이벤트나 조건에 대응하는 작업을 수행합니다.
    
    - 인터럽트는 어떻게 처리하나요?
        
        인터럽트가 발생하면 CPU는 현재 실행 중인 작업을 일시 중단하고, 인터럽트 벡터 테이블(Interrupt Vector Table)을 통해 해당 인터럽트에 대한 ISR의 위치를 찾습니다. 그 후에 ISR을 실행하여 해당 인터럽트를 처리하고, 처리가 완료되면 중단된 작업을 재개합니다.
        
    - Polling 방식에 대해 설명해 주세요.
        
        Polling 방식은 CPU가 주기적으로 하드웨어나 소프트웨어의 상태를 확인하여 인터럽트 여부를 판단하는 방식입니다. CPU는 정기적으로 Polling을 수행하며, 인터럽트가 발생했을 때만 해당 인터럽트를 처리합니다. 하지만 이 방식은 CPU가 일정 시간 동안 계속해서 상태를 확인해야 하므로 효율적이지 않습니다.
        
    - HW / SW 인터럽트에 대해 설명해 주세요.
        
        하드웨어(HW) 인터럽트는 하드웨어 장치에서 발생하며, 예를 들어 마우스나 키보드의 입력, 디스크 컨트롤러의 완료 신호 등이 해당됩니다. 소프트웨어(SW) 인터럽트는 소프트웨어적인 이벤트나 상황에서 발생하며, 예를 들어 프로그램에서 시스템 콜을 호출할 때나 예외적인 상황이 발생할 때 해당됩니다.
        
    - 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
        
        동시에 두 개 이상의 인터럽트가 발생하는 경우, 우선순위를 기반으로 하나의 인터럽트를 선택하여 처리합니다. 보통 높은 우선순위를 가진 인터럽트가 먼저 처리되며, 처리 중인 인터럽트보다 더 높은 우선순위를 가진 인터럽트가 발생하면 현재 처리 중인 인터럽트를 잠시 중단하고 더 높은 우선순위의 인터럽트를 처리합니다. 이를 인터럽트 우선순위 처리라고 합니다. 처리된 인터럽트는 마무리되고, 나머지 인터럽트는 대기열에 대기하게 됩니다. 이렇게 인터럽트를 처리하는 것을 인터럽트 처리기(Interrupt Handler)라고 합니다.
        
- 프로세스가 무엇인가요?
    
    프로세스(Process)는 실행 중인 프로그램으로, 메모리에 올라와 CPU의 할당을 받아 실행되고 있는 상태를 나타냅니다. 각각의 프로세스는 독립적인 메모리 영역을 가지며, 운영체제에 의해 관리됩니다. 프로세스는 프로그램을 실행시키는 데 필요한 모든 정보를 포함하고 있으며, 프로세스 간에는 각각 독립된 메모리 공간이 할당되어 있어 서로 영향을 끼치지 않습니다.
    
    - 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
        
        프로그램(Program)은 디스크에 저장된 실행 가능한 파일을 의미합니다. 프로그램은 실행되기 위해 메모리에 로드되어야 하며, 이 과정에서 프로세스가 됩니다.
        
        프로세스(Process):
        
        - 각각 독립된 주소 공간을 가지며, 메모리를 공유하지 않습니다.
        - 프로세스 간 통신(IPC, Inter-Process Communication)을 사용하여 데이터를 공유할 수 있습니다.
        - 프로세스는 보통 최소한 하나 이상의 스레드를 가지고 있습니다.
        
        스레드(Thread):
        
        - 하나의 프로세스 내에서 실행되는 여러 흐름의 실행 단위입니다.
        - 같은 프로세스 내의 스레드들은 메모리를 공유합니다.
        - 스레드는 경량 프로세스로, 프로세스에 속해 있으며 프로세스 내에서 독립적으로 실행됩니다.
        
    - PCB가 무엇인가요?
        
        PCB(Process Control Block)는 각 프로세스에 대한 정보를 저장하는 운영체제의 자료구조입니다. PCB에는 프로세스의 상태, 프로세스 ID, 프로그램 카운터, 레지스터 값, 메모리 할당 정보 등의 정보가 포함되어 있습니다.
        
    - 그렇다면, 스레드는 PCB를 갖고 있을까요?
        
        스레드는 프로세스 내에서 실행되므로, 각 스레드에 대한 정보도 PCB에 저장됩니다. 프로세스의 PCB 안에는 각 스레드에 대한 정보가 별도의 데이터 구조로 유지됩니다.
        
    - 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
        
        리눅스에서 프로세스는 **`fork()`** 시스템 콜을 통해 생성되며, 스레드는 **`pthread_create()`**와 같은 라이브러리 함수를 사용하여 생성됩니다.
        
        1. **프로세스 생성:**
            - 새로운 프로세스를 생성하려면 보통 **`fork()`** 시스템 콜을 사용합니다. 이는 부모 프로세스에서 호출되며, 부모 프로세스의 복제본을 만들어 새로운 자식 프로세스를 생성합니다.
            - **`fork()`** 시스템 콜을 호출한 후에는 부모 프로세스와 자식 프로세스가 동일한 프로그램 코드, 데이터, 힙, 파일 디스크립터 등을 공유하게 됩니다.
            - 자식 프로세스는 **`fork()`** 함수를 호출한 시점에서 실행 중인 프로세스의 복사본을 얻으며, 이후에는 각자의 독립적인 실행 경로를 가지게 됩니다.
            - 자식 프로세스는 새로운 프로세스 ID(PID)를 가지게 됩니다.
        2. **스레드 생성:**
            - 스레드는 주로 **`pthread_create()`** 함수를 사용하여 생성됩니다. 이는 POSIX 스레드 라이브러리를 사용할 때 주로 사용되는 방법입니다.
            - **`pthread_create()`** 함수는 새로운 스레드를 생성하고, 해당 스레드의 시작 지점으로 지정된 함수를 실행합니다.
            - 새로운 스레드는 생성된 스레드의 시작 지점 함수를 실행하며, 해당 함수는 일반적으로 사용자가 정의한 함수입니다.
            - 스레드는 생성된 프로세스 내에서 실행되며, 메모리와 다른 리소스를 공유합니다. 따라서 같은 프로세스 내에서 생성된 스레드들은 같은 메모리 영역을 공유하게 됩니다.
            - 각 스레드는 고유한 스레드 ID(TID)를 가지게 됩니다.
        
    - 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
        
        좀비 프로세스는 부모 프로세스가 종료 상태를 회수하지 않아 발생
        
        고아 프로세스는 부모 프로세스가 없거나 관리할 수 없을 때 발생
        
        1. **좀비 프로세스 (Zombie Process):**
            - 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않을 때 발생합니다.
            - 자식 프로세스가 종료되면 해당 자식 프로세스의 프로세스 테이블 항목은 삭제되지만, 자식 프로세스가 종료 상태를 회수하기 전에는 프로세스의 메타데이터가 시스템에 남아있습니다. 이 상태를 좀비 상태라고 합니다.
            - 좀비 프로세스는 리소스를 소비하지 않지만, 시스템에는 여전히 존재하므로 좀비 프로세스가 과도하게 많아지면 시스템 리소스가 고갈될 수 있습니다.
            - 부모 프로세스가 **`wait()`** 또는 **`waitpid()`** 함수를 사용하여 자식 프로세스의 종료 상태를 확인하고 회수해야 합니다.
            
        2. **고아 프로세스 (Orphan Process):**
            - 부모 프로세스가 종료되거나 다른 작업을 수행 중이어서 자식 프로세스를 관리할 수 없을 때 발생합니다.
            - 이 경우 자식 프로세스는 부모 프로세스가 없는 상태가 되며, 이후 시스템에서는 이 자식 프로세스의 부모 프로세스를 init 프로세스로 설정합니다. init 프로세스는 시스템 부팅 시에 생성되는 첫 번째 프로세스이며, 모든 고아 프로세스의 부모가 됩니다.
            - 고아 프로세스는 자신의 종료 상태를 정상적으로 회수할 수 있으므로 좀비 프로세스처럼 시스템에 부담을 주지 않습니다.
        
    - 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
        
        리눅스에서 데몬 프로세스(Daemon Process)는 백그라운드에서 실행되는 서비스 형태의 프로세스를 의미합니다. 이러한 프로세스들은 주로 시스템 부팅 시 자동으로 시작되어 백그라운드에서 지속적으로 동작하며, 특정 기능을 제공하거나 시스템 자원을 관리합니다.
        
        데몬 프로세스는 다음과 같은 특징을 가지고 있습니다:
        
        1. **백그라운드 실행:** 데몬 프로세스는 주로 사용자의 시각적인 인터랙션 없이 시스템 서비스를 지속적으로 제공하기 위해 백그라운드에서 실행됩니다.
        2. **시스템 부팅 시 자동 실행:** 시스템이 부팅될 때, 데몬 프로세스는 보통 시스템 초기화 스크립트에서 자동으로 시작됩니다.
        3. **사용자와의 상호작용이 없음:** 일반적으로 데몬 프로세스는 사용자와의 상호작용이 없습니다. 이를 통해 특정 기능을 제공하는 웹 서버, 데이터베이스 서버 등이 있습니다.
        4. **프로세스 수명 관리:** 데몬 프로세스는 시스템이 실행 중일 때 계속해서 실행되며, 필요에 따라 종료되거나 재시작될 수 있습니다.
        
        리눅스 시스템에서는 다양한 데몬 프로세스가 실행됩니다. 예를 들어, 웹 서버인 Apache나 Nginx, 데이터베이스 서버인 MySQL 또는 PostgreSQL, 로그인 관리를 담당하는 SSH 데몬 등이 데몬 프로세스의 예시입니다.
        
    - 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
        
        리눅스에서 프로세스 트리의 루트는 init 프로세스입니다. 이 init 프로세스는 시스템 부팅 시 가장 먼저 실행되며, 모든 다른 프로세스의 부모가 됩니다. init 프로세스의 프로세스 ID(PID)는 1로 설정되어 있습니다
        
- 프로세스 주소공간에 대해 설명해주세요.
    
    프로세스 주소 공간(Process Address Space)은 하나의 프로세스가 실행되는 동안 사용할 수 있는 가상 메모리 주소 범위를 나타냅니다. 이는 프로세스가 메모리를 관리하고 데이터를 저장하는 데 사용하는 영역입니다. 프로세스 주소 공간은 일반적으로 다음과 같은 세 영역으로 구성됩니다:
    
    1. **텍스트 영역(Text Segment 또는 Code Segment):**
        - 프로그램의 명령어들이 포함되어 있는 영역입니다.
        - 실행 파일의 기계어 코드가 로드되며, CPU에 의해 실행됩니다.
        - 텍스트 영역은 보통 읽기 전용으로 지정되어 있습니다.
    2. **데이터 영역(Data Segment):**
        - 전역 변수, 정적 변수 및 상수 등을 저장하는 영역입니다.
        - 초기화된 데이터와 초기화되지 않은 데이터로 구분됩니다.
        - 초기화된 데이터는 프로그램의 시작 시점에 초기값이 할당되며, 초기화되지 않은 데이터는 프로그램 실행 도중에 할당됩니다.
    3. **힙 영역(Heap Segment):**
        - 동적으로 할당되는 메모리를 저장하는 영역입니다.
        - 힙은 프로그램의 실행 도중에 동적으로 메모리를 할당하고 해제할 수 있습니다.
        - 동적으로 할당된 메모리는 프로그래머에 의해 직접 관리됩니다.
    4. 스택 영역(Stack Segment):
        
        스택은 함수 호출 및 복귀 주소 저장, 지역 변수 및 임시 데이터 저장 등의 용도로 사용됩니다. 프로세스의 스택은 일반적으로 메모리 주소가 감소하는 방향으로 자라나며, 호출된 함수와 관련된 데이터를 저장합니다. 스택 프레임(Stack Frame)이라고도 불리는 작은 블록들은 각 함수 호출 시 생성되며, 해당 함수의 매개변수, 지역 변수, 복귀 주소 및 기타 관련 정보를 저장합니다.
        
    
    이러한 영역들은 보통 가상 메모리 주소 공간 내에서 서로 겹치지 않고 별도로 관리됩니다. 또한, 이러한 영역은 운영체제에 의해 관리되며, 프로세스가 실행되는 동안 이 영역에 대한 액세스 권한 및 보호를 제어합니다. 예를 들어, 텍스트 영역은 보통 읽기 전용으로 설정되어 코드의 무결성을 보호하고, 데이터 및 힙 영역은 동적 메모리 할당 및 수정을 가능하게 합니다.
    
    - 초기화 하지 않은 변수들은 어디에 저장될까요?
        
        초기화되지 않은 변수들은 프로세스의 데이터 영역(Data Segment)에 저장됩니다. 이는 프로그램이 시작될 때 메모리에 할당되며, 초기화되지 않은 전역 변수와 정적 변수들이 이 영역에 저장됩니다.
        
    - 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
        
        일반적으로 Stack과 Heap의 크기는 매우 크다고 보기는 어렵습니다. 이들의 크기는 운영체제와 컴퓨터의 구성에 따라 다르며, 프로세스가 실행될 때 동적으로 할당됩니다. 일반적으로 Stack과 Heap의 크기는 프로그램이 실행되는 환경에 따라 변동됩니다.
        
    - Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
        
        접근 속도가 더 빠른 공간은 일반적으로 Stack 영역입니다. 이는 스택이 메모리 접근을 위한 단순한 포인터 조작만으로 이루어지기 때문입니다. 반면에 Heap은 동적으로 메모리를 할당하고 해제하는 데 복잡한 메모리 관리 알고리즘이 필요하므로, 접근 속도가 상대적으로 느립니다.
        
    - 다음과 같이 공간을 분할하는 이유가 있을까요?
        
        Stack과 Heap을 분할하는 이유는 메모리를 효율적으로 관리하고, 서로 다른 종류의 데이터를 보다 안전하게 저장하기 위함입니다. 예를 들어, 스택은 함수 호출 및 지역 변수를 관리하는 데 주로 사용되며, 이는 함수 호출의 재귀적 구조를 지원하고, 지역 변수에 대한 안전한 메모리 할당을 보장합니다. 반면에 Heap은 동적으로 할당된 데이터를 저장하는 데 사용되며, 이는 프로그램의 실행 중에 유연하게 메모리를 관리할 수 있도록 합니다.
        
    - 스레드의 주소공간은 어떻게 구성되어 있을까요?
        
        스레드의 주소 공간은 프로세스의 주소 공간과 거의 동일합니다. 스레드는 프로세스 내에서 실행되므로, 스레드는 프로세스의 코드, 데이터, 힙을 공유합니다. 각 스레드는 고유한 스택을 가지고 있지만, 코드와 데이터, 힙 영역은 모든 스레드가 공유합니다.
        
    - "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
        
        스택영역은 자료구조의 스택과 관련이 있지만, 힙은 연관이 없습니다.
        
        스택은 LIFO(Last-In-First-Out) 구조로, 메모리의 경우 함수 호출 및 지역 변수 관리에 사용됩니다.
        
        자료구조의 '힙'은 이진 트리 형태로 구성된 자료구조로, 최대값 또는 최소값을 빠르게 검색하기 위해 사용됩니다. 반면 메모리의 힙 영역은 동적으로 할당된 데이터를 관리하기 위한 영역입니다.
        
        메모리의 힙 영역은 동적으로 할당된 메모리 블록을 관리하기 위해 사용되며, 이러한 할당과 해제는 프로그래머가 직접 제어할 수 있거나 가비지 컬렉터에 의해 제어됩니다. 
        
        반면에 자료구조의 '힙'은 다양한 용도로 사용되는데, 주로 우선순위 큐를 구현하는 데 사용됩니다. 이진 힙은 일반적으로 배열로 구현되며, 부모 노드의 값이 자식 노드의 값보다 크거나 작은(최대 힙 또는 최소 힙) 완전 이진 트리입니다. 이러한 힙은 삽입과 삭제 연산을 빠르게 수행할 수 있는 장점을 가지고 있습니다.
        
    - IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
        
        IPC(Inter-Process Communication)의 Shared Memory 기법은 공유 메모리 세그먼트를 생성하여 다른 프로세스 간에 데이터를 공유하는 기술입니다. 이 공유 메모리 세그먼트는 각 프로세스의 주소 공간 내에 존재하며, 해당 세그먼트를 통해 프로세스 간에 데이터를 공유할 수 있습니다.
        
        공유 메모리 세그먼트는 일반적으로 물리적인 메모리 주소 공간에 할당됩니다. 이 세그먼트는 여러 프로세스에 의해 동시에 접근될 수 있으며, 이를 통해 데이터를 공유할 수 있습니다. 따라서 각 프로세스는 해당 공유 메모리 세그먼트에 접근하여 데이터를 읽거나 쓸 수 있습니다.
        
        Shared Memory 기법의 이점은 다음과 같습니다:
        
        1. **높은 성능**: 공유 메모리를 사용하면 데이터를 복사하는 대신 직접 메모리에 접근하여 데이터를 전달할 수 있으므로, 높은 성능을 얻을 수 있습니다.
        2. **간편한 통신**: 공유 메모리를 사용하면 데이터를 별도의 통신 메커니즘을 사용하여 전달할 필요가 없으므로, 간편하게 통신할 수 있습니다.
        3. **유연성**: 공유 메모리를 사용하면 다른 프로세스 간에 큰 양의 데이터를 효율적으로 공유할 수 있습니다.
        
        공유 메모리 세그먼트는 운영체제가 제공하는 메커니즘을 사용하여 생성됩니다. 보통 시스템 호출(system call)을 사용하여 공유 메모리 세그먼트를 생성하고, 해당 세그먼트에 대한 포인터를 반환합니다. 이 포인터를 사용하여 프로세스는 공유 메모리 세그먼트에 접근할 수 있습니다.
        
        이러한 이유로 공유 메모리 세그먼트는 각 프로세스의 주소 공간 내에 할당되며, 이를 통해 다른 프로세스 간에 데이터를 효율적으로 공유할 수 있습니다.
        
    - 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
        
        스택과 힙 영역의 크기는 일반적으로 운영체제에 의해 결정됩니다.  일부 운영체제는 사용자가 프로세스의 스택 및 힙 크기를 제한하거나 조정할 수 있는 메커니즘을 제공할 수도 있습니다. 그래서 프로그램 개발자가 직접 크기를 수정하는 것도 가능합니다.
