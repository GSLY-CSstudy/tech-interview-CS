# 1. 시스템 콜이 무엇인지 설명해 주세요

유저 레벨 프로그램이 운영체제 커널에게 서비스나 기능을 요청할 수 있도록 하는 프로세스의 인터페이스

- 운영체제는 시스템 호출을 통한 인터페이스를 제공해서, 사용자 프로그램이 하드웨어나 다른 시스템 리소스와 상호작용할 수 있게 해준다.
- 시스템 호출은 애플리케이션이 low-level 작업(메모리 할당이나 프로세스 관리) 등을 수행하거나 권한이 필요한 작업을 수행하는 것을 가능하게 하는 중요한 역할을 한다.

### 1) 우리가 사용하는 시스템 콜의 예시를 들어주세요.

**파일 관련 시스템 콜**

- open()
    - 파일을 열기 위한 시스템 콜
- read(), write()
    - 파일로 부터 읽거나 파일에 쓰기 위한 시스템 콜
- close()
    - 파일을 닫기 위한 시스템 콜

**프로세스 관련 시스템 콜**

- fork()
    - 새로운 프로세스를 생성하는 시스템 콜
- exec()
    - 새로운 프로그램을 실행하는 시스템 콜
- exit()
    - 프로세스를 종료하는 시스템 콜

### 2) 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

1. 사용자 프로그램이 시스템 콜 호출
    1. 사용자 프로그램이 시스템 콜을 호출하여 서비스를 요청한다. 이 요청을 보통 언어나 라이브러리에서 제공하는 시스템 콜 인터페이스를 통해 이루어진다.
2. 커널 모드 전환
    1. 시스템 콜을 호출하면 CPU는 커널 모드로 전환된다.
    2. 사용자 모드와 커널 모드는 프로세스가 CPU와 다른 시스템 리소스에 접근하는 권한 수준을 나타낸다.
    3. 일반적으로 사용자 프로그램은 사용자 모드에서 실행되며, 커널은 커널 모드에서 실행된다.
3. 시스템 콜 처리
    1. 커널이 사용자 프로그램의 요청을 받으면, 해당 시스템 콜을 처리하기 위해 적절한 커널 함수를 호출한다.
    2. 이 함수는 요청된 작업을 수행하고 결과를 반환
4. 결과 반환
    1. 시스템 콜이 완료되면, 커널은 결과를 사용자 프로그램에 반환한다.
5. 커널 모드 → 사용자 모드로 복귀
    1. 시스템 콜 처리가 완료되면, CPU는 다시 사용자 모드로 전환된다.
    2. 이후 사용자 프로그램은 시스템 콜 호출 이후의 코드를 계속 실행한다.

### 3) 시스템 콜의 유형에 대해 설명해주세요.

- 프로세스 제어
    - 프로세스 생성/종료/일시정지, 재개 등의 작업을 수행한다.
- 파일 관리
    - 파일 생성/열기/읽기/쓰기/닫기 등의 파일 작업을 수행한다.
    - 파일 및 디렉토리의 권한 설정 및 관리를 제공한다.
- 장치 관리
    - 장치 제어: 입출력 장치 (디스크,네트워크 인터페이스,프린터 등)를 관리한다.
- 정보 관리
    - 시스템 정보 : 시간,날짜,시스템 상태등의 정보를 제공한다.
    - 시스템 자원 : 메모리,CPU 사용량등의 자원을 관리 한다.
- 통신 관리
    - 프로세스 간 통신 : 프로세스 간 데이터 전송, 동기화 등을 지원한다.
    - 네트워크 통신 : 네트워크 상에서의 데이터 전송 및 통신 프로토콜을 관리한다.
- 보안 관리
    - 사용자 인증 및 권한 관리 : 사용자 인증,권한 부여, 암호화 등을 지원한다.

### 4) 운영체제의 Dual Mode 에 대해 설명해 주세요.

운영체제의 듀얼 모드는 컴퓨터 시스템의 보안과 안전성을 유지하기 위한 기능이다. 듀얼 모드는 사용자 모드와 커널 모드로 구성된다.

- 사용자 모드
    - 사용자 프로그램이 실행되는 모드
    - 사용자 모드에서는 제한된 시스템 리소스에만 접근할 수 있다.
        - 일반적으로는 사용자가 작성한 응용 프로그램이 이 모드에서 실행된다.
    - 사용자 프로그램은 시스템 콜을 통해 운영체제의 기능을 사용할 수 있다. 하지만 시스템 콜을 통해서만 운영 체제의 기능에 접근할 수 있다.
- 커널 모드
    - 운영 체제의 핵심 부분인 커널이 실행되는 모드
    - 커널 모드에서는 시스템의 모든 리소스에 접근할 수 있다.
        - 이는 프로세스 제어, 메모리 관리, 장치 관리 등의 작업이 가능
    - 특권 명령어를 실행할 수 있는 권한을 가지고 있다.
        - 이러한 명령어는 시스템의 안정성을 유지하기 위해 보안 검사를 거쳐야한다.

### **5) 왜 듀얼 모드로 각 모드가 구분되어 있을까요 ?**

운영체제가 안정적으로 동작하고 보안을 유지하기 위한 중요한 요소

- **보안 강화**: 커널 모드에서는 시스템의 핵심 부분이 실행되므로, 악의적인 사용자가 시스템 리소스에 직접 접근하는 것을 방지합니다.
- **안정성 확보**: 사용자 프로그램의 오류나 잘못된 동작으로 인해 시스템이 손상되는 것을 방지하기 위해, 커널 모드에서만 특정 작업을 실행할 수 있도록 제한합니다.

### 6) 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요

- System call의 고유한 식별자로 구분합니다.
- 유저 프로그램이 system call을 날리면, 커널에게 이 식별자를 제공하고 커널은 이 식별자를 이용해서 어떤 작업을 요청했는지 알 수 있습니다.

# 2. 인터럽트란?

- 컴퓨터 시스템에서 발생하는 이벤트로, CPU가 현재 실행중인 작업을 일시적으로 중단하고 미리 정의된 처리기능을 수행하는 메커니즘
- 인터럽트는 외부 또는 내부적인 사건에 의해 발생할 수 있으며, 주로 하드웨어나 소프트웨어에서 발생한다.

### 1) 인터럽트는 어떻게 처리?

1. 인터럽트 발생
    1. 하드웨어 또는 소프트웨어 이벤트가 발생하여 CPU에게 인터럽트 요청
    2. 하드웨어: 외부 장치에서 데이터 도착 혹은 타이머 만료 등 인터럽트 발생
    3. 소프트웨어: 잘못된 명령어 실행 또는 나누기 오류 같은 예외 상황이 발생하면 소프트웨어 인터럽트 발생
2. 인터럽트 처리 요청
    1. 인터럽트가 발생하면 CPU는 현재 실행중인 작업을 일시 중단하고 해당 인터럽트에 대한 처리를 요청한다.
    2. 이를 위해 인터럽트 핸들러 또는 인터럽트 서비스 루틴이라고 불리는 특수한 코드가 실행된다.
3. 인터럽트 서비스 루틴 실행
    1. CPU는 해당 인터럽트에 대한 ISR을 실행.
    2. ISR은 인터럽트의 원인을 파악하고, 적절한 처리를 수행한다.
4. 인터럽트 처리
    1. ISR은 인터럽트가 발생한 원인에 따라 다양한 작업을 수행
    2. 예를들어 하드웨어의 경우 데이터를 수신하여 메모리에 저장
    3. 예를들어 소프트웨어 경우 예외상황을 처리하거나 불필요한 서비스를 운영 체제에 요청할 수 있다.
5. 인터럽트 처리 완료
    1. ISR이 인터럽트 처리를 완료하면 CPU는 원래 실행되던 작업으로 복휘하여 계속 진행한다.

### 3) 폴링 방식?

- 조건이 변경되었는지 또는 추가 작업을 위해 리소스가 준비되었는지 여부를 반복적으로 쿼리하거나 확인하는 것을 의미한다.
- Polling 방식을 인터럽트 체크에 사용하게 된다면, 특정 시간 간격에 인터럽트 여부를 매시간 확인하고 모니터링 하게 될 것입니다.
- 비교적 구현이 간단할 수 있지만, 주기적으로 확인을 해야해서 리소스 낭비의 요인이 될 수 있다.

### 4) HW / SW 인터럽트에 대해 설명해 주세요.

1. **하드웨어 인터럽트(Hardware Interrupt)**:
    - 하드웨어 인터럽트는 외부에서 발생하는 이벤트로, CPU에게 어떤 장치로부터의 요청이나 상태 변화를 알리는 역할을 합니다.
    - 주로 외부 장치에서의 이벤트(예: 데이터 도착, 타이머 만료)가 발생할 때 사용됩니다.
    - 하드웨어 인터럽트는 하드웨어적인 원인에 의해 발생하므로, 시스템의 하드웨어 레벨에서 처리됩니다.
2. **소프트웨어 인터럽트(Software Interrupt)**:
    - 소프트웨어 인터럽트는 프로그램 실행 중에 명령어나 예외 상황에 의해 발생하는 인터럽트입니다.
    - 주로 프로세스 내부에서의 예외 상황(예: 잘못된 명령어 실행, 나누기 오류)이나 운영 체제의 서비스 요청(예: 시스템 콜)에 사용됩니다.
    - 소프트웨어 인터럽트는 프로그램이나 운영 체제에서 명시적으로 호출하여 사용되므로, 소프트웨어적인 원인에 의해 발생합니다.

하드웨어 인터럽트와 소프트웨어 인터럽트는 모두 CPU가 현재 실행 중인 작업을 일시 중단하고 인터럽트 서비스 루틴을 실행하여 해당 인터럽트를 처리합니다. 하드웨어 인터럽트는 주로 하드웨어 레벨에서 발생하고 처리되며, 소프트웨어 인터럽트는 주로 소프트웨어 레벨에서 발생하고 처리됩니다.

### 4-1) 하드웨어 인터럽트와 소프트웨어 인터럽트 간의 우선순위는 어떻게 결정되나요?

- 하드웨어 인터럽트가 더 높은 우선순위를 갖습니다.
    - 이는 하드웨어 인터럽트가 외부 장치와의 상호 작용이나 시스템의 기본 기능을 담당하기 때문에 중요성이 높기 때문입니다.
- 하드웨어 인터럽트는 CPU의 외부에서 발생하며, 장치의 상태 변화나 외부 이벤트를 처리하기 위한 것입니다.
    - 이러한 이벤트들은 종종 실시간성을 요구하며, 따라서 하드웨어 인터럽트는 빠르게 처리되어야 합니다.
    - 따라서 하드웨어 인터럽트는 더 높은 우선순위를 갖게 됩니다.
- 반면 소프트웨어 인터럽트는 프로그램 내부에서 발생하며, 주로 예외 상황이나 운영 체제의 서비스 요청을 처리하기 위한 것입니다.
    - 하드웨어 인터럽트보다는 일반적으로 낮은 우선순위를 갖게 되며, 우선적으로 처리되어야 할 하드웨어 인터럽트가 없는 경우에만 소프트웨어 인터럽트가 처리됩니다.

우선순위가 높은 하드웨어 인터럽트가 먼저 처리되고, 그 후에 우선순위가 낮은 소프트웨어 인터럽트가 처리됩니다. 이렇게 함으로써 시스템은 빠르고 신속하게 외부 장치와의 상호 작용을 처리하면서도 소프트웨어적인 작업을 충분히 수행할 수 있습니다.

### 5) 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

- 각 인터럽트의 우선순위에 따라 처리됩니다.
- 주로 하드웨어 인터럽트와 소프트웨어 인터럽트는 서로 다른 우선순위를 갖기 때문에, 먼저 발생한 인터럽트부터 처리되고 다음으로 발생한 인터럽트가 처리됩니다.

# 3. 프로세스란 무엇인가?

- 프로세스는 컴퓨터에서 실행 중인 프로그램의 인스턴스를 나타낸다.
- 프로세스는 컴퓨터에서 실행중인 작업의 단위이다.
- 각 프로세스는 메모리에 할당되어 실행되며, CPU의 시간과 다른 시스템 리소스를 사용하여 작업을 수행한다.

### 1) 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

- 프로그램
    - 실행 가능한 파일이며, 컴퓨터에서 작업을 수행하기 위해 설계된 명령어들의 집합이다.
- 프로세스
    - 운영체제로부터 자원을 할당받은 **작업의 단위**
    - 각 프로세스는 독립적인 메모리 공간을 가지며, OS에 의해 관리된다.
    - 여러 프로세스가 동시에 실행될 수 있으며, 각각은 서로 독릭접으로 실행된다.
- 스레드
    - 프로세스 내에서 실행되는 작업의 단위
        - 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**
    - 각 스레드는 프로세스의 자원을 공유하며, 동시에 여러 작업을 수행가능
    - 스레드는 프로세스의 주소 공간과 자원을 공유하기 때문에, 스레드간 통신이 비교적 간단하고 빠르다.
    - 프로세스는 보통 하나 이상의 스레드를 가지고 있으며, 다중 스레드 프로그래밍을 통해 병렬적 처리와 동시성을 구현할 수 있다.

간단히 말해, 프로그램은 실행 가능한 파일이고, 프로세스는 실행 중인 프로그램의 인스턴스이며, 스레드는 프로세스 내에서 실행되는 작업의 단위입니다.

### 1-1) 멀티 프로세싱 vs 멀티 태스킹

- 멀티 프로세싱
    - 여러개의 CPU 코어가 동시에 작업을 처리하는 것
- 멀티 태스킹
    - 단일 CPU에서 여러개의 작업을 동시에 처리하는 것을 의미

### 2) PCB가 무엇인가요

- PCB는 프로세스 제어 블록의 약자이다.
- PCB는 운영체제가 각 프로세스를 관리하기 위해 유지하는 데이터 구조
- 각 프로세스마다 하나의 PCB가 있으며, 이 PCB는 해당 프로세스의 상태 및 실행에 필요한 정보를 저장한다.
- CPU의 자원은 한정되어 있다.
    - 그래서 프로세스들은 돌아가며 한정된 시간만큼만 CPU를 이용한다.

PCB는 프로세스가 생성될 때 만들어지고, 프로세스가 종료될 때 소멸됩니다. 운영 체제는 PCB를 사용하여 프로세스의 상태를 추적하고, 프로세스 간의 스케줄링 및 리소스 할당을 관리합니다.

### 2-1) PCB에 담기는 정보들이 뭐가 있나요?

- 프로세스 ID = PID
    - 특정 프로세스를 식별하기 위해 부여하는 고유의 번호
- 레지스터 값
    - CPU 레지스터의 내용을 저장한다. 이는 프로세스가 다시 실행될 때 상태를 복원하는데 사용된다.
- 프로세스 상태 정보
    - 프로세스가 현재 실행중, 대기중 ,준비중 등의 상태를 나타내는 정보이다.
- CPU 스케줄링 정보
    - 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
- 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
- 입출력 상태 정보
    - 프로세스가 사용하는 입출력 장치와 관련된 정보를 저장한다.

### 3) 그렇다면 스레는 PCB를 가지고 있을까요?

- 스레드는 자체적으로 PCB를 갖고 있지 않습니다.
- 프로세스 내에서 실행되는 모든 스레드는 **하나의 PCB**를 공유합니다.

**스레드는 PCB에 다음과 같은 정보를 저장합니다:**

- 스레드 식별자 (TID)
- 스레드 상태 (실행, 대기, 종료 등)
- 스레드 스택
- 레지스터 값

**스레드가 PCB를 공유하는 이유:**

- 메모리 및 CPU 리소스 절약
- 프로세스 내 스레드 간 빠른 통신
- 일관된 프로세스 환경 유지

### 4) 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

**프로세스 생성**

- 새로운 프로세스를 생성하려면 fork() 시스템 콜을 사용한다.
    - 이는 부모 프로세스의 정확한 복사본을 만들어 자식 프로세스를 생성
    - 자식 프로세스는 부모 프로세스의 주소 공간, 파일 디스크립터, 다른 리소스를 상속
    - 주소 공간만 복사할 뿐, 메모리 공간은 공유하지 않고, 두 프로세스는 같은 프로세스 그룹에 속한다
- exec() 시스템 콜은 프로세스의 이미지를 새로운 프로그램으로 대체할 때 사용된다.
    - 따라서 fork() 후에 exec()를 호출하여 새로운 프로그램을 실행할 수 있다.

**스레드 생성**

- 스레드를 생성하려면 POSIX 스레드 라이브러리를 사용한다.
- pthread_create() 함수를 호출하여 새로운 스레드를 생성한다.
- 이 함수는 새로운 스레드의 핸들을 반환하고, 실행할 함수 및 해당 인수를 지정
- 새로운 스레드는 프로세스의 주소 공간을 공유하며, 동시에 여러 스레드가 같은 코드 및 자원에 접근할 수 있다.

스레드는 같은 프로세스 내에서 생성되며, 동일한 주소 공간 및 기타 리소스를 공유합니다. 이로써 스레드는 경량화되고 빠르게 생성될 수 있으며, 프로세스 간 통신 및 동기화 작업도 더욱 효율적으로 수행됩니다.

### 5) 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

1. **자식 프로세스가 상태를 알리지 않고 죽는 경우**
- 운영체제는 해당 자식 프로세스를 좀비 프로세스로 표시한다.
    - 좀비 프로세스는 프로세스의 테이블에 여전히 남아있지만, 종료된 자식 프로세스의 정보를 유지한다.
- 부모 프로세스가 wait() 또는 waitpid() 함수를 사용하여 자식 프로세스의 종료 상태를 검사하지 않으면, 좀비 프로세스는 프로세스 테이블에 계속 남아있다.
1. **부모 프로세스가 먼저 죽을때** 
- 부모 프로세스가 종료되면, 운영 체제는 부모 프로세스의 자식 프로세스들을 고아 프로세스로 변경한다.
    - 이는 예전에 부모로부터 자식 프로세스의 관리가 끊어진 상태를 의미한다.
- 고아 프로세스들은 운영체제의 init 프로세스가 책임지고 관리한다.
    - init 프로세스는 이러한 고아 프로세스들을 수집하고 종료할 책임이 있다.

따라서, 자식 프로세스의 상태를 정리하고 리소스를 해제하려면 부모 프로세스가 적절한 시점에 자식 프로세스의 종료 상태를 검사해야 합니다. 또한 부모 프로세스가 종료될 때에는 고아 프로세스가 되지 않도록 적절한 종료 절차를 수행해야 합니다.

### 5) 리눅스에서, 데몬 프로세스에 대해 설명해주세요.

**데몬 프로세스**는 사용자와 직접 상호작용하지 않고 백그라운드에서 실행되는 프로세스입니다. 일반적으로 시스템 부팅 시 자동으로 시작되고 시스템이 실행되는 동안 계속 실행됩니다. 

### 6) 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

- 리눅스에서 프로세스 트리의 루트 노드에 위치하는 프로세스는 **`init`** 프로세스입니다.
- **`init`** 프로세스는 시스템의 부팅 과정 중에 처음 시작되며, 모든 다른 프로세스의 조상입니다.
- **`init`** 프로세스는 운영 체제의 핵심 부분으로서 시스템 초기화 및 종료, 사용자 레벨 프로세스의 생성 및 관리, 시스템 서비스의 관리 등을 담당합니다.

# 4. 프로세스 주소 공간에 대해서 설명

프로세스 주소 공간은 프로세스가 메모리 상에서 사용하는 영역을 나타낸다.

각 프로세스는 독립된 주소공간을 가지며, 이를 통해 서로 다른 프로세스들이 메모리를 안전하게 공유하고 동작할 수 있다.

- 코드 영역
    - 프로그램에 내장되어 있는 소스 코드가 들어간다.
    - 수정 불가능한 기계어로 저장되어 있고, 정적인 특징을 가진다.
- 데이터 영역
    - 전역 변수, 정적 변수, 상수등이 저장된다.
    - 초기화 된 전역 변수와 정적 변수가 여기에 위치하며, 프로그램이 실행되면 메모리에 할당 된다.
    - 프로그램이 실행될 때 수정 가능
- 힙 영역
    - 동적으로 할당되는 변수들을 담는다
    - 런타임시 크기가 결정된다.
    - 자바에서는 객체가 여기 저장되고 GC에 의해 정리된다.
- 스택 영역
    - 함수 호출 시 지역 변수, 매개변수,리턴값등을 임시로 저장하는 공간
    - 이 영역은 함수 호출시 기록하고 함수의 수행이 완료되면 사라진다.
    - LIFO 방식의 후입선출 방식을 따른다.
    - 컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정 할당할 수 없다.
        - 따라서 재귀 함수가 반복해서 호출되거나 할 시 스택 오버 플로우가 발생

### 1) 초기화 하지 않은 변수들은 어디에 저장되나

- 데이터 영역이나 BSS 섹션에 저장된다.
- BSS 영역에서는 초기화가 되지 않은 변수가 0또는 NULL로 초기화된다.

따라서 초기화되지 않은 변수들은 프로그램이 실행될 때 메모리에 할당되지만, 초기화되지 않은 상태로 남아 있습니다. 이 변수들은 사용하기 전에 반드시 명시적으로 초기화해야 합니다. 초기화되지 않은 변수들을 사용하면 예측할 수 없는 동작이 발생할 수 있으며, 프로그램의 안정성과 예측성이 저하될 수 있습니다.

### 2) 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

- 스택과 힙의 크기는 매우 크다고 단정 짓기는 어렵습니다.
- 일반적으로 스택과 힙의 크기는 프로그램이 실행될 때 동적으로 결정된다.
    - 스택은 컴파일시, 힙은 런타임시
    - 힙 크기는 **운영 체제가 설정**하며, 사용 가능한 메모리에 따라 달라집니다.

### 3) Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

일반적으로 스택 공간에 접근하는 속도가 힙 공간에 접근하는 속도보다 더 빠르다

- 스택은 LIFO 방식으로 메모리를 할당한다.
    - 즉 마지막으로 할당된 데이터가 먼저 해제된다.
    - 이 방식은 메모리 할당과 해제가 매우 빠르게 이루어지도록한다
    - 또한 CPU 캐시에 자주 저장되므로 데이터 접근 속도가 더욱 향상된다.
- 힙은 동적 메모리 할당을 사용하며, 필요에 따라 메모리를 할당하고 해제한다.
    - 힙은 메모리 할당시 사용 가능한 공간을 찾아야하기 때문에 스택보다 느리다.
    - 캐시에 저장될 가능성이 낮다.

### 4) 다음과 같이 공간을 분할하는 이유가 있을까요?

- 메모리 관리 효율성 향상
    - 메모리를 분할하면 각 영역을 개별적으로 관리할 수 있다.
    - 메모리 사용량을 추적하고 할당/해제를 효율적으로 수행할 수 있게 한다.
- 보안 강화
    - 메모리를 분할하면 프로그램의 일부분만 변경 가능한 영역과 실행 가능한 코드가 분리될수 있다.
    - 이는 프로그램 실행중에 외부에서 악의적인 코드의 주입을 방지하는데 도움된다.
- 성능 향상
    - 메모리를 분할하면 프로그램의 접근 패턴에 최적화된 메모리 할당 및 해제 알고리즘을 사용할 수 있다.

### 5) 스레드의 주소공간은 어떻게 구성?

- 스레드의 주소 공간은 프로세스의 주소 공간과 매우 유사하지만, 스택을 제외한 다른 부분은 모든 스레드가 공유합니다.
- **스택은 각 스레드마다 독립적으로 할당**되므로 다중 스레드 프로그램에서는 스택의 크기와 관리에 특별한 주의가 필요합니다.

### 6) 스택/힙은 자료 구조 스택/힙 과 연관이 있을까? 그렇다면 각 주소 공간의 동작과정과 연계해서 설명

**이름은 같지만 서로 다른 개념입니다.** 하지만, 주소 공간의 동작 방식을 이해하는 데 있어서 자료구조 스택/힙의 특징을 참고할 수 있습니다.

1. **스택 영역**
- 후입 선출 구조를 가진다.
- 함수 호출이 발생하면 해당함수에 필요한 지역변수, 매개변수 등이 스택에 순차적으로 저장된다.
- 함수가 반환되면 스택이 제거되어 이전에 호출된 함수의 스택에 접근할 수 있다.
- 스택은 각 스레드 마다 독립적으로 관리되며, 스택의 크기는 스레드 생성시에 미리 할당되어 있다.
1. **힙 영역**
- 힙 영역은 동적 메모리 할당을 위해 사용된다.
- 힙은 전역적으로 사용되며, 모든 스레드가 공유한다. 따라서 힙에 할당된 메모리는 한 스레드에서 다른 스레드로 전달될 수 있다.
- 힙에 할당된 메모리는 사용자가 직접 관리해야 하므로, 할당된 메모리의 크기와 해제되는 시점은 프로그래머에게 달려있다.

### 7) IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘을 뜻한다

Shared Memory 기법에서는 두 개 이상의 프로세스가 동일한 메모리 공간을 공유합니다. 

IPC(Inter-Process Communication)의 Shared Memory 기법은 프로세스 주소 공간의 힙(Heap) 영역에 들어갑니다. 이는 힙 영역이 모든 프로세스에게 공유되는 메모리 영역이기 때문입니다.

이를 위해서는 각 프로세스가 동일한 메모리 영역을 접근할 수 있어야 합니다. 따라서 Shared Memory 영역은 모든 프로세스에게 공통적으로 접근 가능한 메모리 공간이어야 합니다.

- **힙 영역:** 힙 영역은 동적 메모리 할당에 사용되므로 Shared Memory를 위한 메모리를 할당하는 데 사용할 수 있습니다.

### 8) 스택과 힙 영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

1. **스택**
- 일반적으로 컴파일시에 결정
- 스택 영역의 크기는 보통 스레드 생성 시 미리 할당되며, 이는 일반적으로 개발자가 직접 조절할 수 없습니다.
- 컴파일러 옵션 또는 프로그래밍 언어 특징에 따라 스택 크기를 조정할 수 있다.
1. **힙**
- 운영체제가 설정
- 프로그램 실행중에 동적 메모리 할당/해제.
    - 사용자가 직접 크기를 수정할 수는 없습니다.

따라서 일반적으로 프로그램 개발자가 직접 스택과 힙 영역의 크기를 조절할 수 있는 경우는 제한적이며, 보통은 운영 체제나 실행 환경의 설정에 따라 크기가 결정됩니다.
