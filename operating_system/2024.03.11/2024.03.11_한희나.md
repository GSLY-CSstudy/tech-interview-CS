**1. 시스템 콜이 무엇인지 설명해 주세요.**

프로세스가 실행 중일 때, 운영 체제에서 수행해야 하는 특정 작업이 프로세스에 필요한 경우 프로세스는 작업을 완료하기 위해 커널과 상호 작용할 수 있는 함수를 호출한다. 이 함수를 시스템 콜이라 부르며, 프로세스가 운영체제와 통신할 수 있도록 인터페이스를 제공한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3d9bce6e-12dd-4d13-a1c4-a3573a4bf1cd/120cbece-7008-4ae5-b1dc-f373a39db18a/Untitled.png)

- 우리가 사용하는 시스템 콜의 예시를 들어주세요.
- 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
    
    프로세스가 실행 중인 경우 프로세스는 사용자 모드에서 실행되지만 프로세스가 작업을 완료하기 위해 일부 OS 리소스가 필요한 경우 시스템 콜을 호출한다.
    
    OS의 시스템 콜을 커널 모드에서 우선순위에 따라 실행된다.
    
    시스템 콜이 완료되며 제어권이 유저모드의 프로세스에게 반납된다.
    
    프로세스는 사용자 모드에서 실행을 계속한다.
    
- 시스템 콜의 유형에 대해 설명해 주세요.
    - 프로세스 제어, 파일 관리, 디바이스 관리, 정보 관리, 통신이 있다.
    - 프로세스 제어는 프로세스 생성, 삭제 등을 위한 시스템 호출을 처리한다. 예시로 프로세스에 대한 Load, Execute, Abort 그리고 Wait for Signal 이벤트가 있다.
    - 파일 관리는 생성, 삭제, 읽기 쓰기 등과 같은 파일 조작 이벤트를 처리한다.
    - 디바이스 관리는 디바이스를 요청하고 해제하며 논리적으로 장치를 연결하고 분리하는 데 사용된다.
    - 정보 관리는 시간과 날짜와 같은 시스템에 대한 정보를 유지하는 데 사용된다.
    - 통신은 메시지 보내기 또는 받기와 같은 프로세스 간 통신을 수행하기 위해 연결을 생성하거나 삭제하고 상태 정보 등을 전송하기 위해 사용된다.
- 운영체제의 Dual Mode 에 대해 설명해 주세요
    - Dual Mode는 사용자 모드(= 유저 모드)와 커널 모드로 구성된다.
    - 사용자 모드는 사용자를 위한 동작을 커널 모드는 운영체제를 위한 동작을 담당한다.
    - 사용자 모드는 메모리에 제한된 접근만이 허용되고 하드웨어에 직접적으로 접근할 수 없다.
    - 커널 모드는 모든 시스템 메모리나 하드웨어에 직접적으로 접근할 수 있다.
- 왜 유저모드와 커널모드를 구분해야 하나요?
    - 운영 체제를 보호하기 위함이다. 유저와 운영체제는 시스템 자원을 공유한다. 따라서 유저에게 제한을 두지 않으면 유저가 메모리 내의 주요 운영체제 자원을 망가뜨릴 위험이 생기게 되기 때문이다.
- 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
    - 커널은 각각 시스템 콜을 구분하기 위해 고유번호를 할당하고 번호에 해당하는 제어 루틴을 커널 내부에 정의한다.

**2. 인터럽트가 무엇인지 설명해 주세요.**

운영체제에 현재 프로세스의 실행을 중지하고 ISR(인터럽트 서비스 루틴)을 처리하도록 알리기 위해 발생하는 이벤트이다. ISR은 어떤 소프트웨어나 하드웨어가 중단을 일으켰는지 찾아내고 이를 CPU에게 알리는 역할을 담당한다. 

- 인터럽트는 어떻게 처리하나요?
    
    인터럽트가 발생하면 CPU는 진행 중인 명령의 실행을 완료하고 ISR을 처리한다. 이후 인터럽트가 해결되면 CPU는 인터럽트 이전에 실행이 중지된 지점부터 계속해서 실행한다. 이때 CPU는 컨텍스트 스위칭을 수행하여 프로세스의 상태를 복원하고 프로세스 실행이 중지된 곳부터 계속해서 실행한다.
    
    이때 인터럽트의 우선순위를 확인하고 인터럽트를 처리한다. 현재 실행 중인 프로세스에 비해 우선순위가 낮을 경우 인터럽트가 메모리에 저장된다. 반대로 우선순위가 높으면 CPU는 현재 프로세스의 컨텍스트를 저장한다.
    
- Polling 방식에 대해 설명해 주세요.
    - 인터럽트 우선순위 판별 방법으로 폴링은 소프트웨어적인 방법이다. 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트를 찾아 ISR 실행한다.
    - 우선순위 변경이 쉽고 하드웨어적인 방법에 비해서 우선순위 판단 속도가 느리다.
    - 폴링의 주기가 짧으면 서버 성능에 부담이 가고 길어지면 실시간성이 떨어진다.
- HW / SW 인터럽트에 대해 설명해 주세요.
    - 외부 장치가 특정 요청을 처리하기 위해 **하드웨어 인터럽트**가 발생한다. 하드웨어 인터럽트는 두 가지 유형으로 분류된다.
        - 마스크 가능한 인터럽트 : 무시하거나 비활성화할 수 있음
        - 마스크 불가능한 인터럽트 : 무시하거나 비활성화할 수 없음
    - 일반적으로 프로세스에 예외가 있거나 인터럽트를 발생시키는 특수 명령을 사용할 때 **소프트웨어 인터럽트**가 발생한다.
- 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
    - 우선순위 따져서 처리한다.
    - 일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선순위가 높다. 또한 내부 인터럽트보다 외부 인터럽트가 우선순위가 높다.

**3. 프로세스가 무엇인가요?**

실행 중인 프로그램을 프로세스라 한다. 프로세스는 실행 중 라이프사이클 전반에 걸차 다양한 상태를 가진다. 이를 프로세스 상태라고 한다. 그리고 프로세스와 관련된 모든 정보는 프로세스 제어 블록(PCB)에 저장된다. 

- 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
    - 프로그램은 컴퓨터에서 어떤 작업을 위해 실행할 수 있는 정적인 상태의 파일로 명령어들의 집합이다.
    - 프로세스는 프로그램이 실행되어 돌아가고 있는 상태, 컴퓨터에서 연속적으로 실행되고 있는 동적인 상태의 컴퓨터 프로그램이다.
    - 스레드는 프로세스가 할당 받은 자원을 이용하여 실제로 작업을 수행하는 일꾼이며 실행 단위이다. 프로세스는 최소 한 개 이상의 스레드를 가지며 이를 메인 스레드(main thread)라 한다.
- PCB가 무엇인가요?
    
    컴퓨팅 시스템 내에 존재하는 모든 프로세스에 대한 세부 사항을 캡슐화하는 중요한 데이터 구조이다. 프로세스가 생성되면 해당 프로세스에 대한 고유한 PCB를 OS에 설정한다. 
    
    이는 OS가 프로세스 상태를 적극적으로 모니터링하고 필요할 수 있는 리소스를 효율적으로 관리하고 효율적인 방식으로 프로세스 실행을 감독할 수 있도록 하기 위함이다.
    
    PCB에는 프로세스 ID, 프로세스 우선순위, 프로세스 상태, 계정 정보, 열린 파일 목록 등과 같은 필드가 포함되어 있다.
    
    PCB는 메모리에 **LinkedList 형태**로 저장된다. 프로세스 테이블에는 현재 시스템에서 실행 중인 모든 프로세스에 대한 참조가 포함되어있다. 따라서 OS가 컨텍스트 스위칭을 수행할 때마다 프로세스에 대한 프로세스 테이블을 참조한다.
    
- 그렇다면, 스레드는 PCB를 갖고 있을까요?
    
    스레드는 TCB(Thread Control Block)이 존재한다. 스레드는 기본적으로 프로세스에 귀속된다. 따라서 스레드가 위치한 프로세스의 PCB에 대하여 포인터를 가진다.
    
- 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
    - 프로세스는 fork()라는 시스템 콜을 사용하여 기존 프로세스를 복사하여 자식 프로세스, 즉 새로운 프로세스를 만든다.
- 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
    - 운영체제는 이러한 고아 프로세스를 허용하지 않으며 부모 프로세스가 먼저 종료되면 자식 프로세스의 새로운 부모 프로세스로 init(PID=1)가 설정된다.
    - init 프로세스는 자식 프로세스가 종료될 때까지 기다린 후 wait 함수를 호출하여 고아 프로세스의 종료 상태를 회수한다.
    - 고아 프로세스는 시스템 자원을 낭비할 수 있고 시스템이 프로세스가 종료될 때까지 추적해야하기 때문에 성능 저하의 원인이 된다.
- 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
    - 유닉스(Unix) 운영체제에서 부팅 시 자동으로 켜져 백그라운드에서 계속 실행되는 프로세스이다.
    - 백신 프로그램이나, 그래픽 드라이버와 같이 **눈에 보이지 않는 프로그램**들을 말한다.
    - 반대로 포그라운드 스레드는 인터넷 브라우저, 카카오톡, 인텔리제이 등 **눈에 보이는 프로그램**이다.
- 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
    - pstree로 확인할 수 있으며 루트는 모든 시스템 프로세스의 상위 프로세스이다.

**4. 프로세스 주소공간에 대해 설명해 주세요.**

code, data, heap stack 영역으로 구성

- 초기화 하지 않은 변수들은 어디에 저장될까요?
    - data 영역에는 전역변수와 정적 변수가 저장된다. 이 안에 BSS(Block stated symbo) 영역이 있는데 이 영역에는 초기화되지 않는 전역 변수가 저장된다.
- 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
    - stack은 지역변수, 매개변수, 리턴값 등 잠시 사용되었다가 사라지는 데이터를 저장한다. 함수 호출 시 할당되고 함수 반환 시 소멸되며 컴파일 타임에 크기가 결정된다. 따라서 무한대로 할당할 수 없는데 재귀 함수가 너무 깊어지거나 지역변수를 너무 많이 가지고 있으면 stack overflow가 발생한다.
    - heap은 동적 데이터 영역으로 메모리 주소 값에 의해서만 참조되고 사용된다. 따라서 런타임에 크기가 결정된다. 스택보다 할당할 수 있는 메모리공간이 많다.
- Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
    - heap은 포인터로 메모리 영역을 접근해야하기 때문에 stack에 비해 상대적으로 느리다.
- 다음과 같이 공간을 분할하는 이유가 있을까요?
    - 각 영역이 서로 다른 목적을 가지고 있다. 다라서 영역이 분리되어 있으면 프로그램이 더 안정적이고 효율적으로 동작할 수 있다.
- 스레드의 주소공간은 어떻게 구성되어 있을까요?
    
    thread id, pc(program counter), 레지스터 집합, 스택으로 구성
    
    같은 프로세스에 속한 스레드는 code, data, heap 영역을 공유한다.
    
- "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
    - 자료구조에서 스택은 LIFO 구조이고 힙은 정렬 방법 중 하나이다.
    - 운영체제에서 스택과 힙은 메모리 공간을 나타낸다.
- IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
    - ipc의 shared memory를 통해 여러 프로세스가 하나의 메모리를 공유할 수 있다. shared memory는 ipc 기법 중 가장 빠르며 생성된 공유 메모리는 커널에 의해 관리되며 각 프로세스 메모리의 data 영역에 할당된다.
- 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?
    - 스택은 컴파일 타임에 힙은 런타임에 결정된다.
    - 프로그램 개발자가 아닌 사용자가 이러한 공간의 크기를 수정하기는 어려우며 일반적으로 컴파일러에서 설정할 수 있다.
