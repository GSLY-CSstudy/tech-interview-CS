# 시스템 콜이 무엇인지 설명해주세요

시스템 콜은 애플리케이션과 OS 간의 인터페이스입니다. 애플리케이션은 시스템 콜을 이용하여 OS의 커널 서비스를 요청할 수 있습니다.

## 시스템 콜의 주요 이점

- **추상화**: 개발자는 시스템 콜이 내부를 깊이 이해할 필요가 없습니다. 알지 못하더라도 메모리 할당, I/O 작업들을 수행할 수 있습니다. 시스템의 복잡성보다 애플리케이션 논리에 집중할 수 있게 해줍니다.
- **제어된 액세스**: 시스템 내부와의 직접적인 상호작용을 제한합니다. 이는 시스템의 안정성과 보안으로부터 실수 또는 악의적인 손상이 일어나지 않도록 보장합니다.
- **표준화**: 하드웨어와 OS 간의 차이점을 추상화합니다. 표준화를 통해 애플리케이션은 다양한 환경에서 일관된 작업을 수행할 수 있게 해줍니다. 이로 인해 이식성이 향상됩니다.

## 시스템 콜의 작동 방식

1. 사용자 프로그램은 시스템 콜의 번호와 매개 변수를 레지스터에 설정합니다.
2. 소프트웨어 인터럽트에 의해 커널 모드로 전환합니다.(시스템 콜시 소프트웨어 인터럽트 발생)
3. 커널은 해당 번호에 매핑된 시스템 콜의 루틴을 실행합니다.
4. 작업이 완료되면 결과가 사용자 프로그램에게 반환되고 사용자 모드로 전환됩니다.

## 소프트웨어 인터럽트와 하드웨어 인터럽트의 차이

**소프트웨어 인터럽트**: 프로그램 코드에 의해 의도적으로 발생되는 인터럽트   
**하드웨어 인터럽트**: 하드웨어(키보드, 마우스, 타이머 신호)로부터 발생되는 인터럽트, 해당 장치가 처리를 요구할 때 자동적으로 발생합니다.

## 사용자 모드와 커널 모드의 차이

주된 차이는 권한 수준에 있습니다. 사용자 모드는 제한된 권한으로 실행되고, 직접 하드웨어에 접근하거나 중요한 시스템 설정을 변경할 수 없습니다. 하지만 커널 모드는 권한을 가집니다. 두 모드의 구분은 시스템의 안정성과 보안을 지켜줍니다.

## OS는 왜 전체 권한이 필요한가요?

운영 시스템은 사용자 및 프로세스에 자원을 할당하고, 시스템 전반에 걸친 보안, 잠재적 문제 모니터링이 필요하기 떄문입니다.(전체적인 관리)

## 시스템 콜의 유형에 대해 설명해 주세요.

I/O, 파일 관리, 통신, 프로세스 관리 등이 있습니다.

## 우리가 사용하는 시스템 콜의 예시를 들어주세요. 자바 기준

자바의 `FileInputStream` 객체에서 `read()` 를 호출하면 JVM에서 적절한 시스템 콜로 변환하여 하위 수준을 파일 시스템과 상호작용합니다. 파일 시스템은 파일에서 데이터를 읽어 반환해줍니다.

## JVM을 통해 호출하는 이유

플랫폼 독립성을 보장하기 위해 JVM은 자바 프로그램과 OS의 중간 역할을 담당합니다.   
JVM은 같은 자바 코드가 다양한 운영체제에서 동작할 수 있게 해주고, 개발자는 운영 체제에 종속되지 않고 코드를 작성할 수 있습니다.(JVM이 운영체제 플랫폼에 맞는 시스템 콜로 변환)

## 파일 시스템 호출 작동 방식

1. 파일을 열 때 운영체제는 파일 디스크립터를 생성하고, 프로그램은 통해 접근합니다.
2. 파일 디스크립터를 통해 데이터를 읽어 메모리로 전송하거나, 메모리의 데이터를 파일에 쓸 수 있습니다.

## 파일 디스크립터란 무엇인가요?

파일 디스크립터란 운영체제가 열린 파일을 추적하는데 사용하는 추상화된 핸들입니다. 운영체제는 각 열린 파일에 고유한 파일 디스크립터를 할당하고 이를 이용하여 파일에 접근합니다.

## 운영체제의 Dual Mode 에 대해 설명해 주세요.

듀얼 모드 운영은 운영체제가 커널모드와 사용자모드 라는 두 가지 권한으로 운영하는 것을 말합니다.   
프로그램에 사용자모드을 부여함하여 직접 하드웨어에 대한 접근할 수 없게 하며, 시스템 콜을 통해 작업을 수행합니다.   
운영 체제는 커널 모드로 전체 하드웨어 권한으로 시스템 관리와 하드웨어를 조작합니다.


# 인터럽트가 무엇인지 설명해 주세요.

인터럽트는 프로그램 실행 중 발생하는 이벤트입니다.   
인터럽트가 발생하면 프로그램을 일시 중지시키고, 인터럽트 서비스 루틴을 처리한 후, 다시 프로그램으로 돌아옵니다.   
인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 구분되며, 비동기적으로 발생하는 사건들을 효율적으로 처리합니다.(반대로 폴링이 있음)

## 인터럽트가 필요한 이유

인터럽트는 CPU가 비동기적으로 발생하는 사건들을 효율적으로 처리합니다.   
- 주기적으로 이벤트가 발생한 여부를 체크하는 것이 아니라 비동기적으로 인터럽트를 발생시켜 자원을 효율적으로 사용할 수 있습니다.

## 인터럽트 서비스 루틴(Interrupt Service Routine)

인터럽트가 발생했을 때 실행되는 프로시저, 인터럽트가 발생한 원인을 처리하고 필요한 작업을 수행한다.

## 인터럽트 처리 과정

1. 인터럽트 생성
2. CPU가 커널 모드로 전환
3. ISR 실행 및 처리
4. 작업으로 돌아가기(사용자 모드로 전환)

## 멀티태스킹 환경에서 인터럽트의 역할은 무엇인가요?

### 멀티태스킹을 위한 인터럽트

타이머 인터럽트를 이용하여 프로세스의 실행 시간을 제한하고, 정기적으로 프로세스 간의 전환을 강제합니다.   
이로 인해 CPU의 독점을 막고 시스템 반응 시간을 높입니다.

### 멀티태스킹을 극대화 시켜주는 인터럽트

주기적으로 인터럽트 발생을 확인하는 것이 아니라 비동기적으로 발생하는 인터럽트에 반응하여 불필요한 시스템 연산 시간이 줄어듭니다.   
이로 인해 멀티태스킹 환경에서 더 많은 연산을 처리할 수 있습니다.

## Polling 방식에 대해 설명해 주세요.

폴링 방법은 CPU가 주기적으로 상태를 확인하여 작업이 필요하다면 작업을 진행하는 방식입니다.
인터럽트 방식이 CPU 입장에서 수동적인 반해, 폴링은 능동적이라고 할 수 있습니다.

### 폴링의 장단점

**장점**   
- 인터럽트에 비해 구현이 간단합니다. 단순한 동작만 하는 시스템에서는 폴링이 좋을 수 있습니다.
- 주기적인 모니터링이 필요한 경우, 주기가 안정적이고 오버헤드가 발생하는 인터럽트보다 효율적일 수 있습니다.
- 실시간성이 중요한 시스템에도 적합합니다. 폴링을 주기를 빠르게 하여 실시간으로 확인할 수 있습니다. 인터럽트는 인터럽트를 처리하는 시간에 처리되므로 실시간 반응하지 못할 수 있습니다.(매우 빠른 시스템)

**단점**   
- 주기적으로 확인만 하는 경우 자원의 낭비가 있어 멀티태스킹의 성능을 저하시킬 수 있습니다.

## HW / SW 인터럽트에 대해 설명해 주세요.

하드웨어 인터럽트는 외부 장치로부터 발생한 인터럽트를 말하고, 소프트웨어 인터럽트는 내부 프로세스로부터 발생한 인터럽트를 말합니다.

## 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

낮은 인터럽트 처리 중 높은 우선 순위의 인터럽트가 들어오면 낮은 인터럽트 처리를 중단할 수 있습니다.(무시되거나 이후 다시 실행)
이를 방지하기 위해 인터럽트 처리 중에 특정 인터럽트 작업을 비활성화 할 수도 있습니다.   
반대로 높은 우선 순위의 인터럽트 발생 중 낮은 우선 순위의 인터럽트가 들어오면 대기할 수도 있습니다.




# 프로세스가 무엇인가요?

## 프로그램, 프로세스, 스레드

프로그램은 실행 가능한 코드와 데이터의 집합입니다. 사용자가 프로그램을 실행하면 메모리에 로드하고 실행하는데, 이 인스턴스를 프로세스라고 합니다. 프로세스는 독립적인 실행 단위로 운영체제로부터 메모리를 할당 받습니다.   
스레드는 실행되는 경량 프로세스입니다. 프로세스 내의 메모리를 공유하고 동시에 실행되는 실행 흐름입니다. 스레드는 동일한 프로세스 내의 다른 스레드와 메모리를 공유하지만 스택 영역은 독립적으로 가집니다.

## PCB가 무엇인가요?

PCB(Process Contol Block)는 운영 시스템에서 프로세스를 관리하기 위한 정보가 들어있는 데이터 구조체입니다.

## PCB에 저장되어 있는 정보들

- **프로세스 식별자**
- **프로세스 상태**
- **프로그램 카운터**: 다음에 실행할 명령어의 주소
- **CPU 레지스터**: 프로세스 실행 중인 CPU의 레지스터 값, 컨텍스트 스위칭 이후 복원될 정보
- **프로세스 우선순위**
- **할당된 메모리**
등등

멀티 태스킹 환경에서 프로세스를 조율하는 데에 필수적입니다.

## 스레드는 PCB를 갖고 있을까요?

하나의 프로세스에 속한 모든 스레드들은 같은 PCB를 가지며, 각 스레드들은 독립적인 TCB(Thread Control Blcok)을 가집니다.

## 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

**프로세스**
`fork()` 를 통해 새 프로세스(자식 프로세스)가 생성됩니다. 이후 `exec()` 를 통해 새로운 프로그램을 메모리에 로드할 수 있습니다.   
   
**스레드**
`pthread_create()`를 통해 생성할 수 있습니다.

## 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

**자식 프로세스가 상태를 보고하지 않고 종료하였을 때**   
자식 프로세스는 좀비 프로세스가 됩니다. 부모 프로세스는 `wait()` 를 통해 자식 프로세스를 회수해야 합니다.

**부모 프로세스가 먼저 종료하였을 때**   
자식 프로세스는 고아 프로세스가 됩니다. 리눅스에서 고아 프로세스는 자동적으로 init프로세스(1번 프로세스)의 자식으로 재귀속되며 init프로세스에 의해 종료됩니다. 이는 좀비 프로세스를 방지하고 자원을 효율적으로 관리할 수 있게 해줍니다.

## 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

리눅스에서 데몬 프로세스는 백그라운드에서 실행되는 특수한 종류의 프로세스입니다. 일반적으로 시스템 부팅시부터 종료까지 계속 실행되어 있으며, 사용자 인터페이스 없이 다양한 기능을 제공합니다.   
(웹 서버, 데이터 베이스 서비스 등)

## 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

init프로세스는 프로세스 id 1번을 가지며 시스템 부팅시 첫번째로 실행되는 프로세스입니다. 또한 모든 프로세스의 조상입니다.   

### init 프로세스의 주요 기능

- 시스템 초기화
- 서비스 관리
- 고아 프로세스 관리
- 시스템 종료 및 재부팅

# 프로세스 주소공간에 대해 설명해 주세요.

프로세스가 메모리에 존재하는 방식으로 운영체제에 의해 할당되고 관리됩니다.

- **텍스트 세그먼트**: 실행되는 코드가 저장되는 부분
- **데이터 세그먼트**: 초기화된 전역 변수와 정적 변수
- **스택 세그먼트**: 함수 호출시 필요한 정보들
- **힙 세그먼트**: 동적으로 할당된 메모리가 저장되는 공간, 프로그램 실행 중에 크기가 변할 수 있습니다.

## 초기화 하지 않은 변수들은 어디에 저장될까요?

BBS(Block Started by Symbol) 라는 영역에 보관됩니다.

## Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

스택은 보통 MB 단위, 힙은 GB 단위로 할당됩니다. 보통 둘 다 프로세스 시작시에 할당합니다. 힙 영역은 프로세스 실행 중에도 변경할 수 있습니다.

## Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

스택은 단순하기 때문에 메모리 할당과 해제가 빠르게 이루어집니다. 또한 모여있기 떄문에 캐시를 사용할 수 있어 더 효율적입니다.(힙은 단편화 문제가 있을 수 있음)

## 다음과 같이 공간을 분할하는 이유가 있을까요?

스택은 임시데이터와 로컬 변수를 가지고 있기 때문에 메모리를 빠르게 할당하고 삭제해야 합니다. 또한 많은 메모리를 사용한다면 잘못된 구현일 확률이 높습니다.

힙은 이에 비해 느리지만 조금 더 자유롭게 사용하기 위해 만들어졌다고 생각합니다.

## "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.

함수를 호출하고 반환하면 스택 영역에 LIFO구조로 데이터가 푸시되고 팝됩니다. 이 구조가 자료구조 스택과 비슷합니다.   
힙 영역은 먼저 생성되더라도 나중에 제거될 수 있기 때문에 LinkedList와 비슷한 거 같습니다.

## IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

IPC(Inter Process Communication)의 공유 메모리 기법은 프로세스 내의 별도 영역에 만들어집니다.   
각 프로세스의 독립적인 공간을 보장하면서 데이터를 공유할 수 있게 하기 위해서입니다.
