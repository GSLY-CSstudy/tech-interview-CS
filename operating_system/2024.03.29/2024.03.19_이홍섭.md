# 5. 단기, 중기, 장기 스케쥴러에 대해 설명해주세요

- 장기 스케줄러는 HDD 상의 프로그램을 커널에 등록(or 레디 큐 등록)할 때의 스케줄러
- 단기 스케줄러는 레디 큐의 프로세스를 CPU에 할당하여 실행 상태로 만들때의 스케줄러
- 중기 스케줄러는 메모리에 적재된 프로세스 수를 관리하는 스케줄러

### 1) 현대 OS에는 단,중,장기 스케쥴러를 모두 사용중인가?

- 현대 OS에서는 대부분 장기 스케줄러를 두지 않는다.
- 훨씬 적은 양의 메모리를 활용했던 과거에는 프로세스에 효율적으로 메모리를 할당하기 위해 장기 스케쥴러의 역할이 필요했지만, 비교적 많은 양의 메모리를 활용하는 현대에는 프로세스가 시작되면 장기 스케쥴러 없이 바로 프로세스에 메모리를 할당하여 장기 스케쥴러의 작업없이 레디큐에 넣어주게된다.

### 2) 프로세스의 스케쥴링 상태에 대해 설명해 주세요.

프로세스의 상태는 메모리 할당 상태로 크게 Active(Swapped-in) 상태와 Suspended(Swapped-out) 상태로 나눌 수 있다.

- `Ready` ****: 메모리를 할당 받은 프로세스는 레디 큐에서 프로세서(CPU) 할당을 대기한다.
- `Running` : CPU 스케쥴링(단기 스케쥴링)에 의해 CPU를 할당받은 프로세스는 Running 상태가 되어 작업을 수행한다.
    - 작업 수행 중 스케쥴링에 의해 CPU를 선점 당해 Ready상태가 되거나 I/O 인터럽드 등으로 block이 되어 Asleep 상태로 상태가 전이될 수 있다.
- `Asleep` : 인터럽트 등으로 프로세서 외 다른 자원을 기다리는 상태.
    - 해당 자원을 할당 받으면 Running 상태가 아닌 다시 Ready 상태가 되어 CPU 할당을 대기한다.
- Suspended Ready, Suspended Block : 메모리를 할당 받지 못하거나 빼앗긴 상태.
    - 빼앗기게 된 경우 Memory Image를 Swap device 보관(Swap-out) 했다가 자원을 다시 할당받을 때 해당 Memory Image를 통해 상태를 복구(Swap-In)하게 된다.

### 3) 선점/비선점

**`선점형 스케줄링`**

- 현대 OS가 쓰는 방식으로, 지금 사용하고 있는 프로세스로부터 CPU를 뺏어서, 다른 적절한 프로세스에게 할당해 줄 수 있는 알고리즘
- 장점 : 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다
- 단점 : 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다 (기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정)

**`비선점형 스케줄링`**

- 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
- 장점 : 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점 : 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야 함> 모든 프로세스가 골고루 자원을 이용하기 어렵다

### 3) 선점/비선점에서 존재할 수 없는 상태가 있을까요

- Asleep(Block) 상태는 작업 실행이 불가능한 상태로, 자원할당을 대기하는 등 사전 정의된 다른 작업이 완료될 때까지 작업 수행이 중지되는 상태이다.
- 따라서 Asleep(Block) 상태는 선점 및 비선점 스케줄링 모두에서 존재할 수 없다.

### 4) 메모리가 부족할 경우, 프로세스는 어떠한 상태로 변화?

- Active(Swapped-In) 상태에서의 프로세스는 더 이상 작업을 수행할 수 없게 되기 때문에 Swap-out되어 Suspended(Swapped-Out) 상태로 전이된다.
- 이 때 메모리 부족으로 필요한 데이터를 가져올 수 없는 경우 Block이 되어 다른 프로세스가 끝나기를 기다리거나, OS가 프로세스를 강제로 종료시켜 Terminated 상태로 전이된다.

# 6. **컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?**

**(컨텍스트 스위칭)**

> 한 프로세스(A)에서 다른 프로세스(B)로 실행 순서가 넘어가면?
> 
> - 기존에 실행 되던 프로세스A는 지금까지의 중간 정보를 백업
> - 뒤이어 실행할 프로세스 B의 문맥을 복구(자연스럽게 실행 중인 프로세스가 바뀜)이처럼 기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을 말한다
1. PCB에서 현재 수행중인 프로세스의 상태 저장
2. 새로운 프로세스를 PCB에서 불러와서 실행

### 1) 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?

스레드가 더욱 빠르다

요약하면, 프로세스 간의 컨텍스트 스위칭은 시스템 자원을 더 많이 소비하고 오버헤드가 크지만, 스레드 간의 컨텍스트 스위칭은 더 빠르고 효율적이며 자원 공유가 간단합니다.

- TCB가 PCB보다 가볍다.
    - 프로세스 내 스레드는 공유하는 영역이 많아 TCB에는 stack 및 간단한 레지스터 포인터만 저장하기 때문에 읽고 쓸때 빠르다.
- 캐시 메모리를 초기화 하지 않아도 된다.
    - 프로세스 내 스레드 간에 스택과 레지스터 값 등 일부 컨텍스트 정보만 변경

### 2) 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?

현재 실행중인 프로세스의 상태는 커널 스택에 PCB 형식으로 저장됩니다.

- 저장 되는 정보
    - 프로그램 카운터 : 다음 실행할 명령어의 주소를 가리키는 값
    - 레지스터 상태 : 현재 프로세스의 레지스터 값들이 저장. 이는 프로세스가 중단되고 나중에 다시 재개될 때 동일한 상태로 복구되어야 하는 중요한 정보

### 3) 컨텍스트 스위칭은 언제 일어날까요?

- 인터럽트 처리
    - 하드웨어 장치 또는 소프트웨어 예외가 발생하면 CPU는 현재 실행 중인 프로세스를 중단하고 인터럽트 처리기를 실행합니다.
- 시스템 호출
    - 프로세스가 운영체제 서비스를 요청하기 위해 시스템 호출을 수행하면 컨텍스트 스위칭이 발생합니다.
- 프로세스 스케쥴링
- 프로세스 생성 또는 종료
- 자원 부족
- 멀티 코어 환경

# **7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**

> CPU스케줄링의 대표적인 7가지 알고리즘
> 
> 1. 선입 선처리 스케줄링
> 1. 최단 작업 우선 스케줄링
> 1. 라운드 로빈 스케줄링
> 1. 최소 잔여 시간 우선 스케줄링
> 1. 우선순위 스케줄링
> 1. 다단계 큐 스케줄링
> 1. 다단계 피드백 큐 스케줄링

**`선입 선처리 스케줄링`**

- FCFS ( First Come First Served) 스케줄링
- 단순히 **준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링**
- 먼저 CPU를 요청한 프로세스부터 CPU 할당
- **단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과)**

**`최단 작업 우선 스케줄링`**

- SJF(Shortest Job First) 스케줄링
- 호위 효과를 방지하려면?
- CPU 사용이 긴 프로세스는 나중에 실행, **CPU 사용 시간이 짧은 프로세스는 먼저 실행**
- **CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식**

**`라운드 로빈 스케줄링`**

- RR(Round Robin) 스케줄링
- 선입 선처리 스케줄링 + **타임 슬라이스(time slice)**
- 타임 슬라이스(Time Slice) : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 **선점형 스케줄링**
    - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되, 정해진 시간만큼만 이용
    - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입(문맥교환)

**`타임 슬라이스의 중요성`**

> 타임 슬라이스가 커진다면,
> 
> 
> 선입 선처리 스케줄링(FCFS)의 문제점인 **호위 효과**(프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용)가 생길 수 있고,
> 
> *타임 슬라이스가 지나치게 작으면,*
> 
> 문맥 교환에 발생하는 오버헤드 때문에 CPU의 부담이 가는 우려가 있다
> 

**`최소 잔여 시간 우선 스케줄링`**

- SRT(Shortest Remaining Time) 스케줄링
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링 (선점형 스케줄링)
- **정해진 시간(타임 슬라이스)만큼 CPU를 이용하되,** 다음으로 CPU를 사용할 프로세스는 **남은 작업 시간이 가장 적은 프로세스 선택**

**`우선순위 스케줄링`**

- Priority Scheduling
- 프로세스들에게 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
- 최단 작업 우선 스케줄링, 최소 잔여 시스템 스케줄링 < 우선순위 스케줄링
- 문제점
    - 우선순위가 계속 높은 프로세스만 실행이 되어서 **기아 현상**(starvation)이 발생한다
    - 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입이 되었음에도 불구하고 실행이 연기 된다
- 해결책**에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식**대기 중인 프로세스의 우선수위를 마치 나이 먹듯 점차 증가시키는 방법(우선순위가 낮아도 언젠가는 우선순위가 높아진다)

**`다단계 큐 스케줄링`**

- Multilevel queue 스케줄링
- 우선순위 스케줄링의 발전된 형태
- **우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식**
    - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
    - **우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐에 있는 프로세스 처리**
- 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다
- 하지만 프로세스들이 큐 사이를 이동할 수 없어서, 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다> 기아현상 재발 가능

**`다단계 피드백 큐 스케줄링`**

- Multilevel feedback queue 스케줄링
- 다단계 큐 스케줄링의 발전된 형태
- 다단계 큐 스케줄링에서는 기본적으로 큐간의 이동 불가
- **큐 간의 이동이 가능**한 다단계 큐 스케줄링타임 슬라이스 동안 실행을 다 못 끝내겠다면, 일단 낮은 우선수위로 보낸다고 이해하자
- 자연스럽게 CPU집중 프로세스의 우선순위는 상대적으로 낮아지고, 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐
- 에이징 기법을 적용하여 기아 현상을 예방할 수 있다

### 1) RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.

**`타임 슬라이스의 중요성`**

> 타임 슬라이스가 커진다면,
> 

### 2) 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

- 우선순위를 기반으로 할당하는 멀티 레벨 피드백 큐, 멀티 레벨 큐등을 사용하면 우선순위가 높은 것부터 실행하기 때문에 좋다.

### 3) 동시성과 병렬성의 차이에 대해 설명해 주세요.

### 동시성

- 동시성이란 CPU가 쉬는 쉬간을 최대한 낮추는 것
- task를 번갈아 가면서 실행

### 병렬성

- 실제로 동시에 여러작업이 처리
- 멀티 코어에서 멀티 스레드 동작

### **3) 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?**

- 프로세스가 요구하는 작업 및 프로세싱 시간은 달라지는데 멀티레벨큐로는 이를 대응할 수 없다.
- 아주 오래 걸리는 작업이 계속 우선순위를 높게 차지한다면 다른 프로세스들의 응답 시간 및 TurnArround Time이 높아진다.
- 이를 해결한것이 MLFQ

### 4) FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

**FIFO 스케줄러의 장점:**

- **간단하고 효율적:** 구현 및 이해가 쉽고 오버헤드가 적습니다.
- **공정성:** 작업이 도착한 순서대로 처리되어 모든 작업에 동일한 기회를 제공합니다.
- **예측 가능성:** 작업 처리 시간을 예측하기 쉬워 시스템 관리가 용이합니다.
1. **자원 예약**: 예를 들어, 프린터나 네트워크 자원과 같이 선입선출이 필요한 자원 예약 시스템에서 사용될 수 있습니다.
2. **단순한 환경**: 작업들 간에 실행 우선순위를 정하지 않아도 되는 간단한 환경에서는 FIFO 스케줄러를 사용할 수 있습니다.

### 3) 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

스레드 스케줄링은 일반적으로 다음과 같은 방식으로 이루어집니다:

1. **유저 수준 스케줄링(User-Level Scheduling)**: 어떤 스레드가 CPU를 얼마나 할당받을지 결정하는 것은 일반적으로 운영 체제가 아닌 해당 프로세스의 유저 수준 라이브러리 또는 스레드 라이브러리에 의해 이루어집니다. 이러한 스케줄링은 프로세스 내에서 스레드 간의 우선 순위나 일부 사용자 정의된 정책에 따라 이루어집니다.
2. **커널 수준 스케줄링(Kernel-Level Scheduling)**: 실제로 CPU를 할당받는 스레드는 운영 체제의 커널에 의해 결정됩니다. 커널은 시스템 전반의 자원 할당을 관리하고, 다중 스레드 환경에서는 각 스레드에게 CPU 시간을 할당하고 관리합니다.

이러한 스레드 스케줄링은 일반적으로 프로세스 스케줄링과 유사한 방식으로 이루어지지만, 스레드 간의 특별한 상호 작용과 자원 공유를 고려하여 보다 세밀하게 조정될 수 있습니다.

### 4) 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

1. **유저 스레드의 스케줄링**:
    - 유저 수준 스레드의 스케줄링은 주로 프로세스 내부에서 이루어집니다.
    - 유저 수준 스레드는 해당 프로세스의 사용자 수준 라이브러리나 스레드 라이브러리에 의해 관리됩니다.
    - 일반적으로 사용자 정의된 스케줄링 정책 또는 우선 순위를 기반으로 하며, 운영 체제에 의해 직접적으로 영향을 받지 않습니다.
2. **커널 스레드의 스케줄링**:
    - 커널 수준 스레드의 스케줄링은 운영 체제의 커널에 의해 관리됩니다.
    - 커널 스레드는 프로세스의 커널 영역에서 직접적으로 관리되며, 운영 체제의 자원 관리 정책에 따라 CPU 시간을 할당받습니다.
    - 일반적으로 운영 체제는 커널 수준 스레드의 우선 순위, CPU 점유 시간 등을 고려하여 스케줄링을 수행합니다.
    
    따라서 유저 스레드와 커널 스레드는 서로 다른 수준에서 관리되므로, 스케줄링 알고리즘도 일반적으로 다르다.
    

# 23. **동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해주세요.**

- 블로킹은 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날때까지 기다렸다가 자신의 작업을 시작
- 논 블로킹은 다른 주체의 작업에 관련이 없이 자신의 작업을 하는것 (제어권이 본인한테)
- 동기는 요청한 작업에 대해 완료여부를 따져 순차적으로 처리하는것
- 비동기는 동기와 반대로 요청한 작업에 대해 완료 여부를 따지지 않기 때문에 다음 작업을 그대로 수행하는것
- 비동기 이점
    - I/O 작업과 같은 느린 작업이 발생할 때, 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행할수 있기 때문이다.
- 동기는 커피집에서 줄을 한줄로 서있고 주문을 하고 나올 때까지 기다려라 하는것
- 비동기는 커핒딥에서 캐셔에게 주문을 하면 진동벨을 주고 옆에서 직원이 주는것을 받아가는 것

블로킹/논블로킹은 다른 주체가 작업할 때 자신의 제어권이 있는지 없는지로 볼 수 있고, 동기/비동기는 결과를 돌려주었을 때 결과에 관심이 많은지 없는지로 볼 수 있습니다.

### 1) **그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?**

- 동기-블로킹 : 블로킹의 관점은 제어권에 있기 때문에 다른 작업이 시작되는 동안 동작하지 않는다.동기의 관점은 결과의 처리이기 때문에 결과를 반환하면 해당 업무를 바로 처리하게 된다
    
    ex) 자바 입출력
    
- 동기-논블로킹 : 논블로킹은 자신의 제어권을 가지고 일을 하는 것입니다. 그런데 동기는 결과에 관심이 많으므로 중간중간마다 결과값이 나왔는지 주기적으로 물어보다가 결과값이 나오면, 해당 결과를 가지고 업무를 처리
    
    이와 같은 동기-논블로킹 방식은 특정 작업의 결과가 필요한 경우에도 프로그램의 실행 흐름이 일시 중단되지 않고 다른 작업을 병렬로 처리할 수 있게 해준다.
    
- 비동기-블로킹 : 블로킹이기 때문에 자신의 작업에 대한 제어권이 없고, 비동기이기 때문에 결과를 바로 처리하지 않아도 된다.
    
    일반적으로 사용되지 않고, 특수한 상황에서만 사용된다.
    
- 비동기-논블로킹 : 논블로킹은 다른 작업이 시작되어도 자신이 하던 작업은 멈추지 않는. 따라서 양쪽에서 서로 각자 작업을 처리하게 되고, 다른 작업이 결과가 끝나면 바로 처리하지 않고 자신의 일이 끝나면 처리하게 된다.

### 2) I/O 멀티플렉싱에 대해 설명해 주세요.

- 여러 I/O 작업을 동시에 처리하거나 관리하기 위한 기술
- 요 목적은 프로그램이 블로킹 없이 여러 I/O 작업을 동시에 처리할 수 있도록 하는 것

### 3) 논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요?

논블로킹 I/O를 수행하면, 결과를 기다리지 않고 프로그램이 다른 작업을 수행할 수 있습니다. 그러나 결과를 수신하려면 추가적인 메커니즘이 필요합니다. 주로 사용되는 메커니즘은 다음과 같습니다:

1. **비동기(Asynchronous) 이벤트 처리**: 논블로킹 I/O 작업을 시작한 후, I/O 완료 이벤트를 기다리지 않고 프로그램은 다른 작업을 수행합니다. 이후 I/O 완료 이벤트가 발생하면 해당 이벤트를 처리하여 결과를 수신합니다.
2. **콜백(Callback) 함수**: 논블로킹 I/O 작업을 시작할 때 콜백 함수를 지정할 수 있습니다. 이 콜백 함수는 I/O 작업이 완료되었을 때 호출됩니다. 따라서 콜백 함수를 통해 결과를 처리할 수 있습니다.
3. **이벤트 루프(Event Loop)**: 일반적으로 비동기 I/O를 지원하는 프레임워크나 라이브러리는 이벤트 루프를 사용합니다. 이벤트 루프는 다양한 이벤트를 감지하고 처리하는 메커니즘을 제공합니다. 따라서 논블로킹 I/O 작업의 완료 이벤트를 이벤트 루프를 통해 수신하여 결과를 처리할 수 있습니다.
4. **Future나 Promise**: 일부 언어나 라이브러리는 Future나 Promise와 같은 추상화를 제공하여 비동기 작업의 결과를 표현합니다. 이러한 추상화를 사용하여 논블로킹 I/O 작업의 결과를 수신하고 처리할 수 있습니다.
