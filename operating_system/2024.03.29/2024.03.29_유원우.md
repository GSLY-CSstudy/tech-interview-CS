# Scheduler

![alt text](<../image/2024.03.29_유원우/스케쥴러 설명.png>)

실행할 수 있는 프로세스들은 `ready queue` 에서 대기합니다. 이 때 `ready queue` 에서 어떤 프로세스를 실행할지 스케쥴러가 결정합니다.   
스케쥴러는 CPU에서 실행할 프로세스를 선택하는 역할을 합니다.

# Dispatcher
![alt text](<../image/2024.03.29_유원우/디스패처 설명.png>)

스케쥴러가 실행할 프로세스를 선택하면, 디스패처가 실행중인 프로세스와 스케쥴러가 선택한 프로세스를 `Context switching` 하는 역할을 수행합니다. `Context switching` 은 CPU을 건드는 굉장히 민감한 작업이므로 커널 모드에서 실시합니다.   
`Context switching` 이 끝나면 유저 모드로 전환해주는 역할까지 디스패처가 수행합니다.   
디스패처와 스케쥴러를 동일하게 보는 운영체제들도 존재합니다. 역할상 분리되어 있지만, 구현에 따라 다릅니다.

# Nonpreemtive Scheduling

프로세스가 자발적으로 `running` 상태에서 빠져나가는 스케쥴링 방식입니다. 운영체제가 강제로 다른 상태로 전이시키지 않습니다.

## 특징

- 신사적: 운영체제가 프로세스를 끝까지 기다려주기 때문에
- 협력적(coorperative): 프로세스가 스스로 양보하기 때문에
- 느린 응답성: 프로세스가 모든 작업을 수행하고 넘겨주게 된다면 사용자 입장에서는 느린 응답을 받게 됩니다.

# Preemtive Scheduling

운영체제가 개입을 해서 여러 알고리즘에 따라 스케쥴링을 관리 감독하는 방식입니다. 알고리즘에 따라 실행 중인 프로세스를 강제로 다른 상태로 변경하고 다음 프로세스를 실행시킬 수 있습니다. 

## 특징

- 적극적, 강제적: 운영체제가 강제적으로 개입합니다.
- 빠른 응답성: 알고리즘에 따라 더 자주 실행될 수 있도록 하여 사용자 입장에서 빠른 응답을 받을 수 있습니다.
- 데이터 일관성 문제: 프로세스가 작업을 끝내고 상태가 변경되는 것이 아니라 운영체제가 변경하므로 데이터의 일관성이 문제 생길 수 있습니다. `critical session`, `lock` 등으로 해결할 수 있습니다.

# 스케줄링 알고리즘

## FCFS(First Come, First served)

먼저 도착한 순서대로 처리합니다.

## SJF(Shortest Job First)

CPU burst가 가장 짧은 작업의 프로세스부터 실행합니다.

## SRTF(Shortest Remaning Time First)

남은 CPU burst가 가장 짧은 작업부터 프로세스가 실행합니다.

### CPU burst을 어떻게 예측할까?

- 과거 데이터 사용: 이전 실행에서 CPU 버스트 시간을 추적하여 이를 기반으로 미래의 버스트 시간을 예측합니다.
- 휴리스틱(Heuristic) 방법: 특정 애플리케이션이나 작업의 특성을 고려하여 휴리스틱 또는 경험적 방법을 통해 추정합니다.
- 지수 평균(Exponential Averaging): 최근 CPU 버스트 시간을 중요하게 여기면서 과거의 버스트 시간을 포함하여 평균을 내는 방식입니다.
- 운영체제의 도움을 받음: 운영체제의 다양한 통계 및 모니터링 도구를 이용하여 분석합니다.

## Priority

우선 순위가 높은 프로세스부터 실행합니다.

## RR(Round Robin)

time slice(일정 시간)로 나누어진 CPU Time을 번갈아가며 실행합니다.

# 단기, 중기, 장기 스케쥴러

## 장기 스케쥴러(Long-term Scheduler) 또는 작업 스케쥴러(Job Scheduler)

### 역할

디스크에서 시스템의 메모리로 프로세스를 언제 로드할지 결정합니다. 

### 목적

다중 프로그래밍의 정도를 조절할 수 있습니다. 

### 특징

느린 주기로 실행됩니다. 모든 프로세스가 메모리에 올라갈 필요가 없기 때문에, 리소스 사용을 조절하는 데 중요한 역할을 합니다.

## 중기 스케쥴러(Medium-term Scheduler) 또는 스와핑 스케쥴러(Swapping Scheduler)

### 역할

프로세스를 메모리와 스왑 영역(디스크) 사이에서 이동시키는 스와핑을 담당합니다.

### 목적

특정 시점에서 실행되어야 할 프로세스의 수를 조절합니다.

### 특징

프로세스의 상태를 실행 대기 상태 -> 대기 상태로 변경하거나 그 반대로 변경함으로써, 메모리를 효율적으로 관리할 수 있게 해줍니다.

## 단기 스케쥴러(Short-term Scheduler) 또는 CPU 스케쥴러

### 역할

어느 프로세스가 다음 CPU를 사용할지 결정합니다.

### 목적

응답시간, 처리량, CPU 사용량을 최적화하는 역할을 합니다. 준비 상태에 있는 프로세스 중에서 다음에 실행될 프로세스를 선택합니다.

### 특징

모든 스케쥴러 중 가장 빈번하게 실행됩니다.

# 스케쥴링과 비슷한 방식으로 돌아가는 예시

## 작업 스케쥴러(Job Scheduler) 예시

AWS의 오토 스케일링(auto scaling)을 예로 들 수 있습니다. 오토 스케일링은 애플리케이션 트래픽이 증가할 것으로 예상 될 때 사전에 정의된 스케일링 정책에 따라 자동적으로 추가 자원을 배포합니다. 이는 작업 스케쥴러가 사전에 계획하고 준비하는 것과 같습니다.

## 스와핑 스케쥴러(Swapping Scheduler) 예시

컨테이너 오케스트레이션 시스템에서의 리소스 관리를 예시로 들 수 있습니다. 쿠버네티스와 같은 컨테이너 오케스트레이션 시스템은 실행 중인 컨테이너의 리소스 사용량을 모니터링하고, 필요에 따라 컨테이너를 다른 노드로 이동시키거나 리소스 할당량을 조절합니다. 이는 시스템 전체 부하를 조절하고 메모리 사용량을 최적화하는 스와핑 스케쥴러와 닮아있습니다.

## CPU 스케쥴러 예시

메시지 큐를 사용한 작업 처리를 예시로 들 수 있습니다. 메시지 큐는 들어온 작업을 순차적으로 큐에 넣고, 이를 받는 시스템은 작업 방식에 따라 작업을 결정하여 실행합니다. 이와 같은 방식이 준비 상태에 있는 프로세스 중에서 어느 것을 다음에 실행할지 결정하는 CPU 스케쥴러와 닮아있습니다.

## 참조

[CPU 스케줄러는 프로세스를 어떻게 스케줄링 하는 걸까요? - 쉬운 코드](https://www.youtube.com/watch?v=LgEY4ghpTJI&t=775s)


# Context switching

CPU에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

## 컨텍스트 스위칭에서 말하는 컨텍스트란?

CPU의 상태, 메모리의 상태 등

## 컨텍스트 스위칭이 왜 필요한가?

CPU의 코어는 한정적이지만, 컴퓨터에서 돌아가고 있는 프로세스/스레드는 코어의 개수보다 더 많다.   
컴퓨터에서 돌아가고 있는 프로세스/스레드를 동시에 돌리기 위해서는 CPU 자원을 나누어 최대한 활용해야 한다.   
- 프로세스/스레드를 동시에 실행하기 위해서
- CPU를 최대한 활용하기 위해서

## 컨텍스트 스위칭은 언제 발생하나?

- 주어진 time slice를 다 사용했을 때
- I/O 작업을 할 때
- 다른 리소스를 기다릴 때

## 컨텍스트 스위칭은 누구에 의해 실행되는가?

OS 커널 중 스케쥴러 또는 디스패처에 의해 관리됩니다.

## 컨텍스트 스위칭이 일어나는 과정(스레드 관점)

1. 인터럽트 발생(time slice를 다 사용했을 때는 타이머 인터럽트 발생)
2. 커널 모드로 전환
3. 현재 실행중인 스레드의 상태 저장
4. 다음 태스크 선택
5. 태스트 상태 복원 및 유저 모드로 전환하여 실행 재개

## 프로세스 관점

프로세스는 스레드와 대부분 동일하지만, 중간에 추가 작업이 있습니다.   
각 프로세스는 독립된 가상 주소 공간을 가지고 있기 때문에, 프로세스 컨텍스트 스위칭 시에는 가상 메모리 주소 공간 관련 처리도 수행됩니다.   

### 프로세스 컨텍스트 스위칭 시 추가 작업

- 페이지 테이블 교체
- TLB(Translation Lookaside) 초기화 또는 교체

### 컨텍스트 스위칭이 미치는 간접적인 영향

캐시 오염(cache pollution)이 발생합니다.   
컨텍스트 스위칭 후 캐시를 들여다 보면 이전 프로세스/스레드에서 실행 됐던 정보들이 들어있을 가능성이 높으므로 바뀐 프로세스에게 필요한 정보는 없을 가능성이 큽니다. (프로세스끼리는 메모리를 공유하지 않으므로, 스레드 컨텍스트 스위칭일 경우엔 있을 수도 있음)   

### 캐시 오염 대응 방안

- 캐시 플러싱(cache flushing): 컨텍스트 스위칭이 일어날 때 캐시 내용을 전부 또는 일부 비우는 방식, 지우는 일 또한 오버헤드를 발생시킬 수 있습니다.
- 캐시 파티셔닝(cache partitioning): 캐시를 여러 파티션으로 나누어, 각 프로세스가 자신의 파티션만을 사용하도록 하는 방법, 오염을 방지하지만 캐시 사용의 유연성이 떨어집니다.(리소스 분배와 공정성)
- 캐시 색인화(cache coloring): 메모리 페이지에 '색'을 할당하고, 같은 '색'을 가진 페이지들이 캐시 메모리 내에서 특정 영역에만 매핑되도록 합니다. 컨텍스트 스위칭이 일어날 때 서로 다른 프로세스가 서로의 영역(메모리, 캐시)를 두고 경쟁하는 것을 최소화합니다.(많은 프로세스가 올라오면 결국 경쟁함, 시스템 설계자가 효과적으로 적용해야 함) [캐시 색인화 - 위키피디아](https://en.wikipedia.org/wiki/Cache_coloring)

## 컨텍스트 스위칭 개념을 사용한 예시

### 서버 비동기 I/O

파일 시스템 접근, 네트워크 요청 등의 I/O 작업이 비동기적으로 처리됨으로써, 서버는 블로킹(작업 완료 대기) 없이 다른 요청을 처리할 수 있습니다. 이로 인해 서버의 동시 처리 능력이 향상되어 효율적인 리소스 사용을 가능하게 합니다

#### 주의할 점

- 에러 처리
- 자원 고갈: 비동기 I/O는 효율적인 리소스 사용이 가능하지만, 과도한 비동기 작업은 시스템 리소스를 고갈시킬 수 있습니다. 예를 들어, 동시에 수행되는 대량의 파일 입출력 작업이나 네트워크 요청은 메모리 사용량을 급증시킬 수 있습니다. 필요에 따라 동시에 실행되는 작업의 수를 제한하는 등의 자원 고갈을 예방해야 합니다.
- 테스트와 디버깅의 어려움

## 참조

[컨텍스트 스위칭 뽀개기! - 쉬운 코드](https://www.youtube.com/watch?v=Xh9Nt7y07FE)

# 블로킹I/O와 논블로킹I/O, 동기와 비동기

블로킹I/O와 논블로킹I/O, 동기와 비동기 이 두 가지 개념이 헷갈립니다.   
먼저 블로킹I/O와 논블로킹I/O을 알아보고, 동기와 비동기를 알아보겠습니다. 이후 2개의 개념을 활용하는 작업을 알아보며 명확한 차이와 각각의 특징을 더욱 자세히 느껴보겠습니다.

# 블로킹I/O와 논블로킹I/O

## 블로킹I/O

I/O의 작업을 요청한 프로세스/스레드가 요청이 완료될 때까지 기다리는 것을 말합니다.

![alt text](<../image/2024.03.29_유원우/블로킹IO 설명.png>)

위 그림처럼 스레드가 블로킹IO 작업을 할 때는 요청이 완료될 때까지 기다립니다. 이럴 경우 블락 상태에서 오래 머물 수 있습니다.   
오래 머물러 비효율적처럼 보이지만, 스레드가 다음 동작을 수행할 때 IO 작업으로부터 받는 데이터가 반드시 필요하다면 어쩔 수 없습니다. 블락 상태동안 CPU와 메모리 자원을 점유하고 있다면 정말 비효율적이 됩니다. 그래서 현대 컴퓨터는 멀티스레드 방식으로 이를 극복합니다.

## 논블로킹I/O

프로세스/스레드를 블락시키지 않고 요청에 대한 현재 상태를 바로 반환합니다. 예를 들어, 블로킹I/O에서는 `read` 시에 `read buffer` 가 비어있다면 블락 상태가 됩니다. 하지만 논블로킹I/O에서는 -1이나 특정 값을 즉시 리턴해줍니다.   
논블로킹I/O에서는 반환 받을 데이터를 사용하지 않더라도 다른 작업을 먼저 수행할 수 있을 떄 사용합니다. 

![alt text](<../image/2024.03.29_유원우/논블로킹IO 설명.png>)

위 그림처럼 스레드는 IO작업에 대한 응답을 즉시 받고 다른 작업을 먼저 수행합니다. 다른 작업이 끝나거나 응답값이 필요한 시점에 응답값 반환을 재요청해서 처리합니다. 블로킹I/O처럼 블락 상태가 유지되지 않아 효율적인 것처럼 보이지만 항상 그런 것은 아닙니다. 재요청 처리를 자주하여 오히려 비효율적이 될 수도 있고, 응답값을 즉시 리턴받을 수 없어 빠른 처리가 불가능할 수도 있습니다.

## 블로킹을 효율적으로 처리하는 방법, I/O 멀티플렉싱

I/O 멀티플렉싱에 대해 알아보기 전에 I/O 멀티플렉싱이 왜 생겨났는지부터 알아보겠습니다.   
블로킹과 논블로킹만을 단순히 사용한다면 굉장히 비효율적일 수 있습니다. 많은 스레드들이 존재하고 이 스레드들이 모두 요청을 받는다고 하면 블로킹과 논블로킹은 어떻게 처리할까요? 논블로킹부터 알아보겠습니다.

### 여러 쓰레드와 논블로킹

논블로킹일 때는 여러 스레드들에 요청이 들어왔는지를 주기적으로 전부 검사해주어야 합니다.   
아래 그림에서는 8개의 소켓을 통해 요청을 받을 수 있습니다. 이 경우 주기적으로 8개의 소켓들을 모두 검사합니다.

![alt text](<../image/2024.03.29_유원우/IO 멀티플렉싱 논블로킹 시점.png>)

### 여러 쓰레드와 블로킹

그럼 블로킹으로 하면 효율적으로 개선할 수 있을까요? 아닙니다. 블로킹의 경우 1개의 소켓이 동기화 되기 전까지 다른 소켓들을 체크하지 않습니다. 더 큰 비효율성을 야기할 수 있습니다.

![alt text](<../image/2024.03.29_유원우/IO 멀티플렉싱 블로킹 시점.png>)

### I/O 멀티플렉싱는 무엇이고, 어떻게 해결하는가?

I/O 멀티플렉싱은 관심 있는 I/O 작업들을 묶어 동시에 모니터링하고, 그 중 완료된 I/O 작업들을 한번에 올려줍니다.

![alt text](<../image/2024.03.29_유원우/IO 멀티플렉싱 로직.png>)

다이어그램을 통해 동작 방식을 보면 보다 쉽게 이해할 수 있습니다.

1. 스레드는 소켓에 요청이 들어왔는지 알아보는 것이 아니라 I/O 멀티플렉싱에 read 요청을 합니다.
2. 블로킹I/O일 경우 블락 상태가 되고, 논블로킹I/O일 경우 다른 작업을 수행합니다.(그림은 블로킹 시점)
3. I/O 멀티플렉싱이 완료된 작업을 감지하면 알림을 날려줍니다.
4. 스레드는 알림 작업을 통해 받은 소켓들에게 `read` 수행합니다.(해당 소켓들은 `read`를 바로 수행할 수 있는 상태)

# 동기와 비동기

블로킹과 논블로킹은 IO 작업을 요청한 후, 응답을 대기하여 즉시 작업을 수행할지, 응답을 미루어 나중에 작업을 수행할지로 나뉘는 것을 알 수 있었습니다.   
그렇다면 동기와 비동기는 어떤 특징이 있을까요?

## 동기(sychronous)

동기는 요청을 보낸 프로세스/스레드가 응답을 받아 처리합니다.

![alt text](<../image/2024.03.29_유원우/sychronous 설명 그림.png>)

위 그림은 동기화로 진행되는 커뮤니케이션을 보여주고 있습니다. A는 B로 요청을 보내고 대기/다른 작업을 수행할 수 있고 B에서 보낸 응답을 처리합니다. B도 A과 같은 방식으로 C와 커뮤니케이션을 합니다.

## 비동기(asychronous)

비동기는 요청을 보낸 프로세스/스레드가 응답을 처리하는 대신 다른 프로세스/스레드로 위임합니다.

![alt text](<../image/2024.03.29_유원우/asychronous 설명 그림.png>)

위 그림은 비동기화로 진행되는 커뮤니케이션을 보여주고 있습니다. A는 요청을 보내고 난 뒤 응답을 받지 않습니다. 대신 B가 응답을 처리합니다. B 또한 C에게 응답을 위임합니다. 이처럼 요청에 대한 응답을 처리를 위임하는 것을 비동기라고 할 수 있습니다.   


## 참조

[block I/O vs non-block I/O - 쉬운 코드](https://www.youtube.com/watch?v=mb-QHxVfmcs&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=15)   

[비동기 프로그래밍 - 쉬운 코드](https://www.youtube.com/watch?v=EJNBLD3X2yg)   

[Blocking I/O와 Non-blocking I/O - 널널한 개발자](https://www.youtube.com/watch?v=XNGfl3sfErc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=24)   

[Non-blocking I/O와 Multi-threading은 바늘과 실이다. - 널널한 개발자](https://www.youtube.com/watch?v=H01FkDtllwc&list=PLXvgR_grOs1DiPUK8VSR8SXqKws4O3qkz&index=26)   

[백엔드 개발자들이 알아야할 동시성 2 — 블로킹과 논블로킹, 동기와 비동기 - 블로그 글](https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8)
