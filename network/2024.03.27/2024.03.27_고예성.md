# 3/27 네트워크

- **쿠키와 세션의 차이에 대해 설명해 주세요.**
    
    쿠키와 세션은 HTTP 통신의 특징인 Connectionless와, Stateless 문제를 해결하기 위한 장치입니다. 웹 서비스를 이용하다보면 로그인과 각종 체크박스 등 상태를 저장해야 되는 경우가 생기게 되는데 이를 쿠키와 세션을 사용해 해결할 수 있습니다.
    
    둘의 가장 큰 차이는 사용자의 정보를 저장하는 위치로, 쿠키는 브라우저 내의 저장소에 저장되고 세션은 서버에 저장되게 됩니다. 따라서 보안적인 측면에서 봤을 때, 쿠키는 request 작업을 수행하며 스니핑 될 우려가 있기 때문에 세션이 더 안전합니다. 반면 속도적인 측면에서 봤을 때는 쿠키는 쿠키 자체에 정보를 가지고 있고, 세션은 서버에 정보를 가지고 있기 때문에 쿠기가 더 빠르다는 특징이 있습니다.
    
    만료 시점에 대한 차이도 있습니다. 세션도 결과적으로는 세션ID를 쿠키를 이용해 저장하게 되는데, 이때 쿠키를 설정하면서 expires(유효 일자)나 max-age(만료 기간)를 지정하지 않으면 ’세션 쿠키’로 저장이 되고, 지정하면 ‘지속 쿠키’로 저장되게 됩니다. 세션 쿠키의 경우 브라우저가 종료되는 시점에서 삭제되며, 지속 쿠키는 브라우저를 닫더라도 지정된 만료 시점이 되기 전까지 유지된다는 차이가 있습니다.
    
    - **세션 방식의 로그인 과정에 대해 설명해 주세요.**
        
        클라이언트가 어떤 웹 사이트에 접속하게 되면 해당 사이트는 고유한 `세션ID`를 생성해 클라이언트에게 주게 됩니다. 이를 받은 클라이언트는 세션ID를 쿠키에 저장하게 되고, 이후 매 요청마다 해당 세션ID는 쿠키에 담겨 전송되게 됩니다. 서버는 세션ID를 보고 해당 클라이언트의 각종 상태를 알 수 있고, 로그인을 하게 된다면 해당 세션ID의 로그인 상태를 유효한 값으로 바꿔 저장하게 됩니다. 이후의 요청에서는 해당 세션ID를 가진 클라이언트의 로그인 상태가 유효하기 때문에 별도의 로그인없이 서비스를 이용할 수 있습니다.
        
    - **HTTP의 특성인 Stateless에 대해 설명해 주세요.**
        
        Stateless를 직역하면 무상태라는 것으로 서버가 클라이언트의 이전 상태를 기억하고 있지 않는다는 것입니다. 때문에 다음 요청을 받는 서버가 이전 요청을 받은 서버일 필요가 없어 서버의 스케일 아웃에 유연하다는 장점이 있지만, 그만큼 클라이언트가 많은 양의 데이터를 보내야 하는 단점이 있습니다.
        
    - **Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?**
        
        Stateless가 무상태를 의미하기 때문에 상태를 유지하는 세션 방식은 이에 반합니다. 하지만 현대의 웹 서비스들을 살펴보면 불가피하게 클라이언트의 상태를 유지해야 하는 경우가 많으며, 무상태를 지향하기 위해 매 요청마다 필요한 정보를 모두 담아 서버와 I/O하는 경우 통신에서 오는 부하와 코스트가 더 클 수 있기에 세션 방식을 사용하는 것 같습니다.
        
    - **규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?**
        
        스케일 아웃된 서버 모두가 세션 정보를 공유해야 되므로 Session만을 저장하는 Session Storage를 별도로 만들어 모든 서버에서 해당 Storage를 바라보게 하는 방법이 있습니다. 물론 Session Storage에서 오류가 나는 경우, 전체에 영향을 미친다는 단점이 있지만 이를 대비해 백업용 Session Storage를 준비해놓는다면 해결할 수 있을 것 같습니다.
        
    
- **HTTP 응답코드에 대해 설명해 주세요.**
    
    HTTP 응답코드는 HTTP 요청에 대한 처리 결과를 나타내기 위한 코드로 크게 5가지로 분류됩니다. 1로 시작하는 100번 대부터 5로 시작하는 500번 대까지 있으며, 각각 정보, 성공, 리다이렉션, 클라이언트 오류, 서버 오류를 의미합니다. 각 분류 내에서는 좀 더 자세한 분류를 위해 401이나 403과 같이 숫자가 나뉘기도 합니다.
    
    - **401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?**
        
        401은 비인증, 403의 권한부족을 의미합니다. 둘 다 사용자측의 모종의 이유로 인한 비인증에 대한 응답이지만, 403은 401과 다르게 클라이언트가 누구인지 알고 있다는 차이가 있습니다. 예를 들어 인증이 안 된 상태의 클라이언트가 관리자 권한의 작업을 요청한다면 서버는 해당 사용자가 일반 사용자인지, 관리자인지 모르기 때문에 401을 통해 인증이 필요함을 표현해야 됩니다. 하지만 일반 사용자가 권리자 권한의 작업을 요청한다면 해당 사용자가 누군지는 알지만 해당 작업에 권한이 없음을 의미하는 403을 표현해야 합니다.
        
    - **200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.**
        
        둘 다 HTTP 요청에 대한 성공을 나타내는 응답이지만, 200은 데이터 요청에 성공해 요청한 데이터가 응답으로 반환되고, 201은 데이터 생성에 성공해 새로운 리소스가 생성되었음을 나타냅니다. 보통 POST나 PUT 요청에 대해 성공적으로 실행되면 201 응답을 사용합니다.
        
    - **필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.**
        
        특정한 상황이나 사용 사례에 따라 사용자가 임의의 응답 코드를 정의하고 사용할 수 있습니다. 이러한 경우에는 사용자가 정의한 응답 코드를 사용하기 위해 사용자가 관리하는 클라이언트 및 서버에서 이를 지원하도록 설정해야 합니다.
        
        그러나 사용자 정의 응답 코드를 사용하는 것은 일반적인 HTTP 통신 규약을 벗어나며, 이로 인해 다른 개발자들이나 시스템과의 상호 운용성이 떨어질 수 있습니다. 따라서 사용자 정의 응답 코드를 사용할 때는 이러한 점을 고려하여야 합니다.
        
        또한, 표준 외의 응답 코드를 사용할 때는 해당 응답 코드에 대한 문서화와 설명이 필요하며, 다른 개발자나 팀원들에게 적절히 전달되어야 합니다. 이렇게 함으로써 응답 코드의 의미와 사용 방법에 대한 혼동을 최소화할 수 있습니다.
        

- **HTTP Method 에 대해 설명해 주세요.**
    
    HTTP 메서드는 주어진 리소스에 수행하길 원하는 작업을 의미하며 데이터를 요구하는 GET, 추가하는 POST, 수정하는 PATCH, 삭제하는 DELETE 등의 메서드가 있습니다.
    
    HTTP는 **요청 메서드**를 정의하여, 주어진 리소스에 수행하길 원하는 행동을 나타냅니다. 간혹 요청 메서드를 "HTTP 동사"라고 부르기도 합니다. 각각의 메서드는 서로 다른 의미를 구현하지만, 일부 기능은 메서드 집합 간에 서로 공유하기도 합니다. 이를테면 응답 메서드는 [안전](https://developer.mozilla.org/ko/docs/Glossary/Safe)하거나, [캐시 가능](https://developer.mozilla.org/ko/docs/Glossary/Cacheable)하거나, [멱등성](https://developer.mozilla.org/ko/docs/Glossary/Idempotent)을 가질 수 있습니다.
    
    ### GET
    
    `GET` 메서드는 특정 리소스의 표시를 요청합니다. `GET`을 사용하는 요청은 오직 데이터를 받기만 합니다.
    
    ### HEAD
    
    `HEAD` 메서드는 `GET` 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.
    
    ### POST
    
    `POST` 메서드는 특정 리소스에 엔티티를 제출할 때 쓰입니다. 이는 종종 서버의 상태의 변화나 부작용을 일으킵니다.
    
    ### PUT
    
    `PUT` 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.
    
    ### DELETE
    
    `DELETE` 메서드는 특정 리소스를 삭제합니다.
    
    ### CONNECT
    
    `CONNECT` 메서드는 목적 리소스로 식별되는 서버로의 터널을 맺습니다.
    
    ### OPTIONS
    
    `OPTIONS` 메서드는 목적 리소스의 통신을 설정하는 데 쓰입니다.
    
    ### TRACE
    
    `TRACE` 메서드는 목적 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다.
    
    ### PATCH
    
    `PATCH` 메서드는 리소스의 부분만을 수정하는 데 쓰입니다.
    
    - **HTTP Method의 멱등성에 대해 설명해 주세요.**
        
        HTTP 메서드의 멱등성은 동일한 요청을 여러 번 보내더라도 리소스의 상태가 항상 동일하게 유지되는 성질을 의미합니다. 즉, 같은 요청을 반복해서 보내면 항상 동일한 결과를 얻을 수 있습니다.
        
        예를 들어, GET 메서드는 서버에서 리소스를 가져오는 용도로 사용됩니다. GET 요청은 리소스를 읽는 것이므로 여러 번 요청을 보내더라도 리소스의 상태는 변경되지 않습니다. 따라서 GET 메서드는 멱등한 메서드입니다.
        
        반면에, POST 메서드는 새로운 데이터를 생성하거나 업데이트할 때 사용됩니다. POST 요청은 새로운 리소스를 생성하므로 같은 요청을 여러 번 보내면 각각 다른 리소스가 생성될 수 있습니다. 따라서 POST 메서드는 일반적으로 멱등하지 않습니다.
        
        이러한 멱등성의 개념은 웹 애플리케이션의 설계 및 구현에서 중요한 역할을 합니다. 멱등한 메서드를 사용하면 클라이언트와 서버 간의 통신이 예측 가능하고 안정적으로 이루어지며, 일부 문제가 발생했을 때 재시도 등의 대응이 가능해집니다.
        
        이때 동일함을 따지기 위해서는 서버의 상태만을 보며 응답코드가 다르다고 멱등성이 없는 것은 아닙니다. 예를 들어 DELETE 메서드는 어떠한 리소스를 삭제했을 때 처음 요청에는 200의 잘 삭제되었음이 응답되지만, 또 요청하게 되면 404의 해당 데이터가 없다고 응답됩니다. 그럼에도 불구하고 첫요청이나 재요청 모두 DB의 상태는 동일할 것이므로 멱등성이 있다고 할 수 있습니다.
        
    - **GET과 POST의 차이는 무엇인가요?**
        
        먼저 GET은 요청한 리소스를 얻기 위해 사용되며 POST는 리소스에 데이터를 추가하기 위해 사용됩니다. 때문에 가장 큰 차이는 데이터를 담아 보내는 body의 유무로 GET 요청은 body가 없지만 POST 요청은 body가 존재합니다. 또한 GET은 캐시가 되며 브라우저에 기록이 남지만, POST는 캐시가 되지 않고 기록 또한 남지 않습니다.
        
    - **POST와 PUT, PATCH의 차이는 무엇인가요?**
        
        POST 새로운 리소스를 생성하기 위해서 사용되는 메서드입니다. PUT는 해당 리소스가 없다면 생성하고, 있다면 수정하며, PATCH는 이미 있는 리소스를 수정합니다. POST와 둘의 차이는 POST와 PATCH는 멱등성이 없지만 PUT은 멱등성이 있습니다. PUT과 PATCH의 디테일한 차이는 PUT은 전달되지 않은 데이터에 대해서는 null로 수정하기 때문에 전체 컬럼에 대한 값을 수정할 때 사용되지만 PATCH는 전달된 데이터만 수정하기 때문에 부분 수정을 위해 사용됩니다.
        
        **PUT이 멱등한 경우의 예시:**
        
        가정: 클라이언트가 PUT 메서드를 사용하여 사용자의 이름과 이메일을 업데이트하는 요청을 보냅니다.
        
        - 초기 상태:
            - 사용자의 이름: "John"
            - 사용자의 이메일: "john@example.com"
        - 클라이언트가 PUT 요청을 보냅니다:
            - 요청: PUT /users/123
            - 바디: {"name": "Jane", "email": "jane@example.com"}
            - 이 요청은 사용자의 이름을 "Jane"으로, 이메일을 "jane@example.com"으로 완전히 대체합니다.
        
        **PATCH가 멱등하지 않은 경우의 예시:**
        
        가정: 클라이언트가 PATCH 메서드를 사용하여 사용자의 이름과 이메일을 업데이트하는 요청을 보냅니다.
        
        - 초기 상태:
            - 사용자의 이름: "John"
            - 사용자의 이메일: "john@example.com"
        - 클라이언트가 첫 번째 PATCH 요청을 보냅니다:
            - 요청: PATCH /users/123
            - 바디: {"name": "Jane"}
            - 이 요청은 사용자의 이름을 "Jane"으로 업데이트합니다.
        - 클라이언트가 두 번째 PATCH 요청을 보냅니다:
            - 요청: PATCH /users/123
            - 바디: {"email": "jane@example.com"}
            - 이 요청은 사용자의 이메일을 "jane@example.com"으로 업데이트합니다.
            
        
        **DELETE가 멱등한 경우의 예시:**
        
        가정: 클라이언트가 DELETE 메서드를 사용하여 사용자를 삭제하는 요청을 보냅니다.
        
        - 초기 상태:
            - 사용자 ID가 123인 사용자가 존재합니다.
        - 클라이언트가 DELETE 요청을 보냅니다:
            - 요청: DELETE /users/123
            - 이 요청은 사용자 ID가 123인 사용자를 삭제합니다.
        
    - **HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?**
        
        GET 요청은 브라우저에 캐시되며 기록이 남을 수 있습니다. 이에 민감한 정보를 GET의 body를 담아 요청하게 되면 보안상의 문제를 야기할 수 있기 때문에 지양하고 있습니다. 또한 아직 많은 개발자들이 가지고 있는 GET의 의미론적 역할에 대해 생각때문에 GET의 body를 지원하지 않는 클라이언트나 서버가 있을 수 있기 때문에 지양하고 있기도 합니다.
        

- **HTTP에 대해 설명해 주세요.**
    
    HTTP는 Hyper Text Transfer Procotol의 약자로 HTML과 같은 하이퍼텍스트 문서를 전송하기 위한 Application단의 프로토콜입니다. 생성 목적에 맞게 초기에는 HTML 문서만을 주고 받았지만 현재는 다양한 데이터를 주고 받는데 사용합니다. 클라이언트가 요청을 하기 위해 연결을 연 다음 응답을 받을때 까지 대기하는 전통적인 클라이언트-서버 모델을 따르며, Connectionless하고 Stateless하다는 특징이 있습니다.
    
    - **공개키와 대칭키에 대해 설명해 주세요.**
        
        둘 모두 암호화 기법 중 하나로 대칭키는 암호화와 복호화에 쓰이는 키가 같은 것을 의미합니다. 다만 이 방법은 암호문과 키를 전달하는 과정에서 키를 탈취당할 우려가 있기에 안전하지 않습니다. 이를 보완하기 위해 나온 공개키는 암호화에 쓰이는 키와 복호화에 쓰이는 키가 다른 비대칭키로, 두 개의 키 중 하나는 모두에게 공개되어 있는 공개키, 하나는 개인만이 알고 있는 개인키로 이루어져 있습니다. 따라서 상대방의 공개키를 통해 암호화한 암호문을 상대방에게 보내면 상대방은 개인키를 이용해 복호화할 수 있습니다.
        
    - **왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?**
        
        HTTPS 핸드셰이크 과정에서 인증서를 사용하는 이유는 기본적으로 두 가지입니다.
        
        1. **서버 신원 확인**: 클라이언트가 서버에 연결할 때, 서버가 제대로된 서버인지 확인할 필요가 있습니다. 인증서는 서버의 신원을 확인하는 데 사용됩니다. 인증서는 신뢰할 수 있는 기관에 의해 발급되며, 서버의 공개키와 서버의 도메인 이름 정보를 포함합니다. 클라이언트는 서버로부터 받은 인증서를 검증하여 해당 서버가 클라이언트가 의도한 서버인지 확인합니다.
        2. **안전한 통신을 위한 키 교환**: HTTPS 핸드셰이크 과정에서는 공개키 암호화 기술이 사용됩니다. 서버의 인증서에는 공개키가 포함되어 있으며, 클라이언트는 이를 사용하여 안전한 통신을 위한 세션 키를 생성합니다. 이 세션 키는 클라이언트와 서버 간의 통신을 암호화하는 데 사용됩니다.
        
    - **SSL과 TLS의 차이는 무엇인가요?**
        
        SSL은 Netscape가 개발한 암호화 프로토콜로 1996년 3.0 버전 이후로 업데이트가 되고 있지 않으며, 각종 보안 취약점이 발견되어 이를 업데이트한 최신 암호화 프로토콜을 TLS라고 합니다. 이름이 바뀐 이유는 SSL의 개발사 중 하나가 업데이트에 참여하지 않으면서 소유권을 가져오기 위해 바꿨습니다. 사실상 SSL의 업데이트 버전이라고 보면 되며 보안과 속도면에서 많이 개선되었습니다.
        
    
- **웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.**
    
    일반적으로 불리는 소켓은 프로그램이 네트워크 상에서 데이터를 주고 받을 수 있도록 사용하는 연결부라고 생각하면 됩니다. 여기서 HTTP 통신의 특징인 Connectionless으로 인해 실시간 통신이 안되는 불편함을 해결하고자 나온 것은 웹소켓으로 IP와 포트번호의 조합을 통해 주소를 특정하는 것이 소켓과 비슷하지만 일반 소켓은 OSI 7계층 중 4계층인 Transport layer에서 동작하는 것과 다르게, 웹 소켓은 7계층인 Apllication layer에서 동작합니다.
    
    - **HTTP의 Connectionless란**
        
        HTTP 프로토콜이 요청과 응답 간에 연결을 유지하지 않는 특성을 의미합니다. 각각의 요청과 응답은 서로 독립적이며, 이전 요청과 응답과는 상관없이 처리됩니다.
        
        기본적으로 HTTP는 클라이언트가 서버에 요청을 보내면 서버는 요청을 처리하고 응답을 반환한 후에 연결을 끊습니다. 즉, 한 번의 요청과 응답이 완료되면 해당 연결은 종료됩니다. 이러한 방식은 매우 단순하고 간단하며, 서버의 부하를 줄일 수 있습니다.
        
        Connectionless 특성은 HTTP/1.0 이후에도 지속되었으나, HTTP/1.1부터는 지속적인 연결을 지원하는 기능이 추가되었습니다. 이를 통해 동일한 호스트와의 여러 요청에 대해 단일 TCP 연결을 유지할 수 있습니다. 이를 통해 여러 요청 간에 연결 설정 및 해제로 인한 오버헤드를 줄일 수 있습니다.
        
        그러나 여전히 각각의 요청과 응답은 독립적으로 처리되며, Connectionless의 개념은 계속 유지됩니다. 따라서 HTTP 프로토콜은 기본적으로 Connectionless이지만, HTTP/1.1부터는 지속적인 연결을 지원하여 성능을 향상시킬 수 있습니다.
        
    
    - **소켓과 포트의 차이가 무엇인가요?**
        - **소켓(Socket)**: 클라이언트와 서버 간의 통신을 수행하는 데 사용됩니다. 클라이언트와 서버는 각각 소켓을 생성하여 서로 통신하고 데이터를 주고받습니다.
        - **포트(Port)**: 호스트(컴퓨터) 내에서 서로 다른 프로세스나 서비스를 식별하기 위한 번호입니다. 포트는 특정 프로세스가 네트워크로부터 들어오는 요청을 받아들이는 데 사용됩니다.
        
        소켓은 클라이언트와 서버 간의 연결을 나타내는 것이고, 포트는 호스트 내에서 특정 프로세스나 서비스를 식별하는 데 사용됩니다. 클라이언트와 서버는 소켓을 사용하여 통신하고, 호스트는 포트를 사용하여 특정 프로세스에 요청을 전달합니다.
        
        네트워크에 연결되어 IP가 할당된 통신이 가능한 단말을 호스트라고 부르는데, 호스트 내에는 여러가지 프로세스들이 동작하고 있을 수 있습니다. IP를 타고 호스트에게 도착한 데이터는 특정 프로세스에 도달해야 되는데, 이때 특정 프로세스를 식별하기 위해 호스트가 부여하는 고유한 숫자가 바로 포트입니다. 
        
        소켓은 어떠한 프로세스가 네트워크 상에서 데이터를 주고 받기 위해 열어두는 문같은 것입니다. 하나의 호스트 내에게서 포트는 고유하나, 호스트는 통신을 위해 여러 소켓을 생성할 수 있습니다. 따라서 같은 프로세스 내에서도 소켓은 고유하지 않을 수 있습니다.
        
    - **여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?**
        
        모두 다를 수도 있고, 포트 번호가 같은 소켓이 있을 수도 있습니다. 포트 번호는 하나의 호스트내에서 고유하지만, 하나의 호스트는 여러 개의 소켓을 열 수 있으므로 같은 IP, 같은 포트수를 가지고 있다 하더라도 여러 개의 소켓이 존재할 수 있습니다.
        
    - **사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?**
        
        일반적으로 사용자의 요청이 많아지면 소켓이 많이 생성됩니다. 소켓은 네트워크 통신을 위한 엔드포인트이며, 클라이언트와 서버 간의 통신에 사용됩니다. 사용자가 요청을 보낼 때마다 일반적으로 하나의 소켓이 생성되고 사용됩니다.
        
        하지만 소켓은 일반적으로 연결을 유지하지 않는 일회성 연결 방식인 TCP 소켓이 많이 사용됩니다. 클라이언트가 요청을 보내면 서버는 해당 요청에 대한 응답을 하고 소켓을 닫을 수 있습니다. 이렇게 소켓을 사용한 후에는 연결이 종료되고 해당 소켓은 다시 사용 가능한 상태가 됩니다.
        
        그러나 많은 사용자 요청이 동시에 발생하면 많은 소켓이 생성되고 사용될 수 있습니다. 이를 처리하기 위해서는 서버가 충분한 리소스를 갖추고 있어야 합니다. 또한 서버의 성능과 확장성을 고려하여 적절한 소켓 관리 및 네트워크 리소스 관리가 필요합니다.