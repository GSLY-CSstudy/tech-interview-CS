# 6. HTTP1.1과 HTTP/2의 차이점

### HTTP 프로토콜에 대해 설명해주세요

HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다.HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다.

- 장점
통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK
- 단점
이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다.이를 해결하기 위해 쿠키(cookie)나 세션(session)을 사용해서 데이터를 처리한다.

## HTTP/1.1

- HTTP/1.0은 연결 한개당 하나의 요청을 처리하도록 설계됨과 다르게 HTTP/1.1은 한 번의 TCP 연결을 통해 여러 개의 요청과 응답을 처리할 수 있다.
  - 이는 지속적인 연결을 지원하고, 여러 요청과 응답을 병렬로 처리 가능
  - 때문에 대기시간이 길어지지 않음.
- 요청과 응답이 순차적으로 이루어진다.
- 매번 TCP 연결을 하는 것이 아니라, 한번 TCP를 초기화 한 후 Keep-alive 옵션으로 여러개의 파일을 송수신 하게 바뀌었다
- HTTP/1.0 에서 자주 일어났던 HOL Blocking이 HTTP/1.1에서는 병렬 요청 및 응답을 처리할 수 있으므로 HOL Blocking이 발생할 가능성이 줄어듭니다. 
> HOL 블로킹이란 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하

#### Http/1.0 에서 자주 일어난 문제들
>- RTT(Ropund Trip Time / 패킷 왕복 시간)
>    - 매번 요청별로 연결을 만들게 되고 HTTP의 특성상 3-way handshake가 반복적으로 일어나며 불필요한 RTT의 증가와 네트워크 지열을 초래
>- 무거운 Header 구조
>    - 매 요청마다 중복된 헤더 값을 전송
>    - 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송

- RTT(Ropund Trip Time / 패킷 왕복 시간)
    - 매번 요청별로 연결을 만들게 되고 HTTP의 특성상 3-way handshake가 반복적으로 일어나며 불필요한 RTT의 증가와 네트워크 지열을 초래
- 무거운 Header 구조
    - 매 요청마다 중복된 헤더 값을 전송
    - 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송

### 개선 방법

1. Image Spriting
    
    다양한 아이콘 이미지 파일의 요청 횟수를 줄이기 위해 아이콘을 하나의 큰 이미지로 만든 다음 CSS에서 해당 이미지의 좌표값을 지정하여 표시하는 방법
    
2. Domain Sharding
    
    브라우저들이 여러 개의 연결을 생성해 병렬로 요청을 보내는 것
    
3. Minified CSS/JS
    
    데이터의 용량을 줄이기 위해 CSS, JS를 축소
    
4. Load Faster
    
    head 태그에 자바스크립트를 삽입하고 async나 defer옵션을 사용해 브라우저 파싱을 block하지 않고 로드
    
5. Data URI Scheme
    
    HTML 문서 내 이미지 리소스를 Base64로 인코딩된 이미지 데이터로 직접 기술하는 방법으로 서버로의 요청을 줄임
    
6. 구글의 SPDY
    
    Throughtput이 아닌 Latency 관점에서 고속화한 새로운 프로토콜
    

## HTTP/2.0

- Multiplexed Streams : **연결 한개로 동시에 여러 개**의 메세지를 주고 받을 수 있으며, 응답은 수서에 상관없이 스트림으로 받는다.
- Stream Prioritization : **리소스 간의 의존관계**에 따른 우선순위를 설정하여 리소스 로드 문제를 해결
- Server Push: 클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다.
- Header Compression: 헤더의 중복이 발생할 경우 Static/Dynamic Header Table 개념을 이용해 중복을 검출하고, 중복되지 않은 index 값 + Header 정보를 허프만 인코딩 방식으로 데이터를 전송한다.

### 1) HOL BLOCKING에 대해 설명해주세요

- HTTP/1.x 버전대에서 발생하는 문제로 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다.

### 2) HTTP/3.0의 주요 특징에 대해 설명해 주세요.

- TCP가 아닌 **UDP** 기반
- TCP위에서 돌아가는 HTTP/2와는 달리 HTTP/3은 QUIC이라는 계층 위에서 돌아간다.
    - UDP는 TCP보다 **빠른 속도**를 가진다
        - UDP는 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다
        - 결국 3way handshake 같은 논리적 연결 과정(흐름 제어 또는 혼잡 제어)이 별도로 없다
        - **신뢰성보다는 연속성**이 중요한 서비스에 사용
            - ex) 실시간 서비스 (streaming)
- 또한 선택적으로 사용했던 TLS를 HTTP/3에서는 필수적으로 사용해야 힌다.
    - 첫 연결에는 1RTT의 시간, 이후의 연결에는 이전의 연결에서 사용한 정보를 그대로 사용하기 때문에 0RTT가 필요한 굉장히 빠른 속도를 가지고 있다.

# TCP와 UDP의 차이

둘 다 OSI 7계층 중 4계층인 Transport layer에 속하는 프로토콜

### TCP

- 연결 지향적 프로토콜
    - 3 way handshaking 과정을 통해 연결 한다.
    - 4 way handshaking 과정을 통해 연결을 해제한다.
- 전송 순서를 보장한다. 수신 여부 확인, 논리적 연결 수립/해제
- `데이터의 흐름 제어`
    - 데이터의 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지
- `혼잡 제어`
    - 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 방지
- 위의 이유로 **안정성**과 **신뢰성**을 강점으로 한다
- 위의 이유로 UDP 보다 속도가 느리다.
- 연속성보다 신뢰성이 있는 전송이 중요할 때 사용하는 프로토콜
    - ex 파일 전송 등
- 전이중,점대점 방식
    - 전이중 : 전송이 양방향에서 동시에 일어남
    - 점대점 : 연결이 정확히 2개의 종단점을 가지고 있음

### UDP

- 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다.
    - 데이터의 수신여부를 확인하지 않는다.
- 결국 3way같은 논리적 연결 과정이 별도로 없다. (흐름 제어 또는 혼잡제어 등도 마찬가지)
- TCP 보다 빠른 속도를 가진다.
- 신뢰성보다는 연속성이 중요한 서비스에 사용된다
    - 실시간 서비스

## 1. CheckSum이 무엇인가요

- 송신된 자료의 **무결성을** 보호하는 방법

## 2. TCP와 UDP중 어느 프로토콜이 Checksum을 수행할까요

- TCP UDP 둘다 수행하지만 TCP에서는 필수적이고 UDP는 선택적이다

## 3. 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?

- 불가능하다. 오류를 정정하기 위해서는 해밍코드 기법을 활용해야한다.
- 하지만 TCP에서는 체크섬을 통해 오류가 검출되는 경우 해당 패킷을 버림으로서 해당 패킷의 재전송을 요청할 수 있습니다.

## 4. TCP가 신뢰성을 보장하는 방법?

- TCP는 데이터에 대해 응답 패킷을 받아야 통신이 정상적으로 이루어졌다고 판단
- 응답 패킷을 받지 못하면 유실 되었다고 판단하고 패킷을 다시 보낸다.
- 또 TCP는 각 데이터 세그먼트에 일련 번호를 할당하여 순서를 유지한다. 수신하는 쪽은 받은 세그먼트의 checksum을 계산해 손상된 데이터인지 확인하고 손상 유무에 따라 응답을 다르게 해 손상된 데이터는 데이터 재전송을 요청한다.

## 5. TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.

- AIMD
    - 처음에 패킷을 하나씩 보내고 문제없이 도착하면 윈도우의 크기를 하나씩 증가시키며 전송
    - 전송에 실패하면 윈도우 크기를 반으로 줄인다.
- Slow Start
    - 윈도우의 크기를 두배씩 증가시키다가 혼잡을 감지하면 1로 줄이는 작업을 반복하는 Slow Start 기법

### 6. 왜 HTTP는 TCP를 사용하나요?

- HTTP는 웹상에서 여러 데이터를 주고받기 위해 사용된다. 즉 사용자에게 제공되어야 할 리소스들을 받게 되는데, 이러한 정보들은 유실되거나 손상되면 안된다.그래서 신뢰도있는 TCP를 사용한다.

### 7. 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?

- HTTP/3은 이전의 HTTP와 다르게 TCP기반의 HTTP들이 가지는 고질적인 문제인 속도와 HOL BLOCKING을 해결했다는 것이다.

### 8. **본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?**

- 속도 및 IP 변경으로 인한 재연결 과정이 없기 때문에 PC환경 뿐만이 아닌 모바일 환경에 더 적합한 UDP를 선택
- UDP는 흔히 말하든 흰 도화지같은 프로토콜이기 때문에 개발자의 커스터마이징에 따라 TCP와 비슷한 성능을 낼 수도 있습니다.
- 개발을 진행할 때, 좋은 기능이 모두 들어간 무거운 라이브러리보다는 필요한 기능만 가지고 있는 가벼운 라이브러리를 선호하는 것과 같이 저 또한 UDP를 선택할 것 같습니다.

### 9. 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?

- 웹 브라우저는 어떤 서버가 TCP를 사용하는지 또는 UDP를 사용하는지를 직접 알 수 없습니다. 대신, 클라이언트(브라우저)와 서버 간의 통신 프로토콜은 주로 서버의 기능 및 클라이언트의 요청 유형에 따라 결정됩니다.

# 3-Way HandShake에 대해 설명

- TCP가 **연결을 수행하는 과정**
- 클라이언트가 SYN 요청을 보내면 서버는 이를 받아 SYN에 ACK를 더한 응답을 보내준다.
- 그 후 클라이언트가 이 해당 응답을 받았다는 ACK를 보내면 연결이 완료되고, 데이터를 송수신 받을 준비가 끝난다.
1. SYN 단계
    1. 클라이언트는 ISN(고유 시퀀스)을 담아 서버로 SYN(연결 요청 플래그) 전송
2. SYN + ACK 단계
    1. 서버는 SYN을 수신하고, 서버의 ISN을 클라이언트로 보낸다 (승인번호는 클라이언트 ISN + 1)
3. ACK 단계
    1. 클라이언트는 승인번호를 담아 ACK(응답 플래그)를 서버로 전송

### 1. ACK, SYN 같은 정보는 어떻게 전달하는 것일까

- TCP 패킷의 헤더를 통해서 전달 된다.

### 2. 2-way handshkaing을 하지 않는 이유

**신뢰성 파악이 불가**

- 3hand와 다르게 2 hand 에서는 일부만 확인된다.
- 클라이언트는 서버의 ACK 신호를 통해 둘다 확인 할 수 있으나 서버는 3 hand의 마지막 단계인ACK를 받을 수 없기 때문에 송수신 할 수 없다.

**ISN 동기화 불가**

- 서버의 ISN을 받을 수 없기 때문에 세그먼트의 순서를 파악할 수 없다.

### **3. 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?**

- Simultaneous Open을 통해 가능하다. TCP는 두 개의 파이프를 사용하는 양방향 전이중 통신에 해당한다. 연결이 된 후에는 자연스럽게 양방향 데이터 전송이 가능하다.
    
    1.각자 서로 SYN Segment를 보낸다. - SYN-SENT
    
    2.SYN Segment를 받으면 ACK Segment를 보낸다. - SYN-RCVD
    
    3.ACK Segment가 도착하면 각자 Established 된다.
    
    > 3-Way Handshake 보다 빠르다.
    > 

# 4-way handshake에 대해 설명

- TCP에서 **연결을 해제 하는 과정**이다

> 1. 클라이언트가 연결을 닫으려 할 때 서버로 FIN 플래그를 전송
> 
> 1. 서버는 FIN 수신에 대한 응답으로 ACK 전송 → 클라이언트가 받으면 자신의 통신이 끝날때 까지 일정시간 대기 (time wait)
> 2. 일정 시간 이후 서버는 연결 종료에 합의한다는 의미로 → 클라이언트에게 FIN 전송
> 3. 클라이언트는 FIN 수신에 대한 응답으로 ACK 전송 → 서버 닫힘 → 어느 정도 대기 후 클라이언트도 대기

## 1. 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까

- FIN 플래그를 통해 알 수 있다.

### 2. 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?

**Abrupt connection release**

- RST 세그먼트가 전소되면 갑작스러운 연결 해제가 수행된다.
- ACK를 보내거나 기다리는 작업이 필요하짐 않고 바로 연결이 종료된다.
- RST 비트를 1로 설정한 세그먼트를 전송한다.송신자는 패킷을 보내고 연결을 종료, 수신자는 패킷을 받으면 바로 연결을 종료

**RST를 사용해 연결을 종료하는 경우**

1. 보안 위반의 경우
- 악성 코드가 존재한다고 판단되면 연결을 즉시 종료하여 보호할 수 있다.
1. 자원이 부족해 자원 할당을 해제해야하는 경우
2. TCP 연결에 장애가 발생한 경우
- 즉시 연결을 끊고 새로운 연결을 시도해 정상적인 통신으로 돌아올 수 있다.

### 3. 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?

- `Time_out`을 통해 일정 시간이 지나면 스스로 Close한다.

### 4. TIME_WAIT은 왜 존재하는가?

- 지연 패킷이 발생할 수 있다, 지연 패킷을 처리하지 못한다면 **데이터 무결성** 문제 발생 -> 해당 패킷이 도착하도록 잠시 기다린다
- 두 장치가 연결이 닫혔는지 확인한다
